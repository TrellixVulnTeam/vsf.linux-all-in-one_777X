 builtin/add.c                      |  76 ++++++++-
 builtin/am.c                       |  11 ++
 builtin/blame.c                    |  80 +++++++--
 builtin/branch.c                   |  49 ++++--
 builtin/cat-file.c                 |   8 +
 builtin/check-attr.c               |  15 ++
 builtin/check-ignore.c             |  33 ++++
 builtin/check-mailmap.c            |  17 ++
 builtin/checkout-index.c           |  12 ++
 builtin/checkout.c                 |   8 +
 builtin/clean.c                    |  17 +-
 builtin/clone.c                    | 142 ++++++++++++++--
 builtin/column.c                   |   8 +
 builtin/commit-graph.c             |  22 ++-
 builtin/commit-tree.c              |  12 ++
 builtin/commit.c                   | 242 +++++++++++++++++---------
 builtin/config.c                   |  80 +++++++--
 builtin/count-objects.c            |  14 ++
 builtin/credential-cache--daemon.c |  24 +++
 builtin/credential-store.c         |   8 +
 builtin/describe.c                 |  40 ++++-
 builtin/diff-tree.c                |  15 ++
 builtin/difftool.c                 |  17 ++
 builtin/fast-export.c              | 121 +++++++++++++
 builtin/fast-import.c              | 337 +++++++++++++++++++++++++++----------
 builtin/fetch-pack.c               |   2 +-
 builtin/send-pack.c                |   2 +-
 common-main.c                      |  12 +-
 compat/obstack.c                   |  13 ++
 compat/regex/regcomp.c             |  30 +++-
 compat/regex/regex.c               |   5 +
 compat/regex/regex_internal.h      |   4 +
 compat/terminal.c                  |  55 +++++-
 ewah/ewah_bitmap.c                 |   9 +
 git-compat-util.h                  |   7 +
 negotiator/default.c               |   8 +
 negotiator/skipping.c              |   8 +
 refs.c                             |  58 ++++++-
 refs/debug.c                       |  14 +-
 refs/files-backend.c               |   8 +-
 refs/iterator.c                    |  14 +-
 refs/packed-backend.c              |  17 +-
 refs/ref-cache.c                   |   2 +-
 refs/refs-internal.h               |   8 +-
 trace.h                            |   4 +
 trace2.c                           |  16 ++
 trace2/tr2_cfg.c                   |  13 ++
 trace2/tr2_cmd_name.c              |   8 +
 trace2/tr2_dst.c                   |  12 ++
 trace2/tr2_sid.c                   |   9 +
 trace2/tr2_sysenv.c                |   9 +
 trace2/tr2_tgt.h                   |  10 ++
 trace2/tr2_tgt_event.c             |  18 ++
 trace2/tr2_tgt_normal.c            |  16 +-
 trace2/tr2_tgt_perf.c              |  16 +-
 trace2/tr2_tls.c                   |  12 ++
 56 files changed, 1561 insertions(+), 266 deletions(-)

diff --git a/builtin/add.c b/builtin/add.c
index 84dff3e796..7367262ed8 100644
--- a/builtin/add.c
+++ b/builtin/add.c
@@ -22,10 +22,25 @@
 #include "submodule.h"
 #include "add-interactive.h"
 
+#ifdef __VSF__
+# include "git_port_vsf.h"
+#endif
+
 static const char * const builtin_add_usage[] = {
 	N_("git add [<options>] [--] <pathspec>..."),
 	NULL
 };
+#ifdef __VSF__
+# define patch_interactive (git_ctx->builtin_add.__patch_interactive)
+# define add_interactive (git_ctx->builtin_add.__add_interactive)
+# define edit_interactive (git_ctx->builtin_add.__edit_interactive)
+# define take_worktree_changes (git_ctx->builtin_add.__take_worktree_changes)
+# define add_renormalize (git_ctx->builtin_add.__add_renormalize)
+# define pathspec_file_nul (git_ctx->builtin_add.__pathspec_file_nul)
+# define include_sparse (git_ctx->builtin_add.__include_sparse)
+# define pathspec_from_file (git_ctx->builtin_add.__pathspec_from_file)
+# define legacy_stash_p (git_ctx->builtin_add.__legacy_stash_p)
+#else
 static int patch_interactive, add_interactive, edit_interactive;
 static int take_worktree_changes;
 static int add_renormalize;
@@ -33,6 +48,7 @@ static int pathspec_file_nul;
 static int include_sparse;
 static const char *pathspec_from_file;
 static int legacy_stash_p; /* support for the scripted `git stash` */
+#endif
 
 struct update_callback_data {
 	int flags;
@@ -347,6 +363,19 @@ static int edit_patch(int argc, const char **argv, const char *prefix)
 static const char ignore_error[] =
 N_("The following paths are ignored by one of your .gitignore files:\n");
 
+#ifdef __VSF__
+# define verbose (git_ctx->builtin_add.__verbose)
+# define show_only (git_ctx->builtin_add.__show_only)
+# define ignored_too (git_ctx->builtin_add.__ignored_too)
+# define refresh_only (git_ctx->builtin_add.__refresh_only)
+# define ignore_add_errors (git_ctx->builtin_add.__ignore_add_errors)
+# define intent_to_add (git_ctx->builtin_add.__intent_to_add)
+# define ignore_missing (git_ctx->builtin_add.__ignore_missing)
+# define warn_on_embedded_repo (git_ctx->builtin_add.__warn_on_embedded_repo)
+# define addremove (git_ctx->builtin_add.__addremove)
+# define addremove_explicit (git_ctx->builtin_add.__addremove_explicit)
+# define chmod_arg (git_ctx->builtin_add.__chmod_arg)
+#else
 static int verbose, show_only, ignored_too, refresh_only;
 static int ignore_add_errors, intent_to_add, ignore_missing;
 static int warn_on_embedded_repo = 1;
@@ -356,15 +385,17 @@ static int addremove = ADDREMOVE_DEFAULT;
 static int addremove_explicit = -1; /* unspecified */
 
 static char *chmod_arg;
+#endif
 
-static int ignore_removal_cb(const struct option *opt, const char *arg, int unset)
+int ignore_removal_cb(const struct option *opt, const char *arg, int unset)
 {
 	/* if we are told to ignore, we are not adding removals */
 	*(int *)opt->value = !unset ? 0 : 1;
 	return 0;
 }
 
-static struct option builtin_add_options[] = {
+#ifndef __VSF__
+static const struct option builtin_add_options[] = {
 	OPT__DRY_RUN(&show_only, N_("dry run")),
 	OPT__VERBOSE(&verbose, N_("be verbose")),
 	OPT_GROUP(""),
@@ -394,6 +425,7 @@ static struct option builtin_add_options[] = {
 	OPT_PATHSPEC_FILE_NUL(&pathspec_file_nul),
 	OPT_END(),
 };
+#endif
 
 static int add_config(const char *var, const char *value, void *cb)
 {
@@ -425,7 +457,11 @@ static const char embedded_advice[] = N_(
 static void check_embedded_repo(const char *path)
 {
 	struct strbuf name = STRBUF_INIT;
+#ifdef __VSF__
+# define adviced_on_embedded_repo (git_ctx->builtin_add.check_embedded_repo.__adviced_on_embedded_repo)
+#else
 	static int adviced_on_embedded_repo = 0;
+#endif
 
 	if (!warn_on_embedded_repo)
 		return;
@@ -444,6 +480,9 @@ static void check_embedded_repo(const char *path)
 	}
 
 	strbuf_release(&name);
+#ifdef __VSF__
+# undef adviced_on_embedded_repo
+#endif
 }
 
 static int add_files(struct dir_struct *dir, int flags)
@@ -499,6 +538,39 @@ int cmd_add(int argc, const char **argv, const char *prefix)
 	char *seen = NULL;
 	struct lock_file lock_file = LOCK_INIT;
 
+#ifdef __VSF__
+struct option builtin_add_options[] = {
+	OPT__DRY_RUN(&show_only, N_("dry run")),
+	OPT__VERBOSE(&verbose, N_("be verbose")),
+	OPT_GROUP(""),
+	OPT_BOOL('i', "interactive", &add_interactive, N_("interactive picking")),
+	OPT_BOOL('p', "patch", &patch_interactive, N_("select hunks interactively")),
+	OPT_BOOL('e', "edit", &edit_interactive, N_("edit current diff and apply")),
+	OPT__FORCE(&ignored_too, N_("allow adding otherwise ignored files"), 0),
+	OPT_BOOL('u', "update", &take_worktree_changes, N_("update tracked files")),
+	OPT_BOOL(0, "renormalize", &add_renormalize, N_("renormalize EOL of tracked files (implies -u)")),
+	OPT_BOOL('N', "intent-to-add", &intent_to_add, N_("record only the fact that the path will be added later")),
+	OPT_BOOL('A', "all", &addremove_explicit, N_("add changes from all tracked and untracked files")),
+	OPT_CALLBACK_F(0, "ignore-removal", &addremove_explicit,
+	  NULL /* takes no arguments */,
+	  N_("ignore paths removed in the working tree (same as --no-all)"),
+	  PARSE_OPT_NOARG, ignore_removal_cb),
+	OPT_BOOL( 0 , "refresh", &refresh_only, N_("don't add, only refresh the index")),
+	OPT_BOOL( 0 , "ignore-errors", &ignore_add_errors, N_("just skip files which cannot be added because of errors")),
+	OPT_BOOL( 0 , "ignore-missing", &ignore_missing, N_("check if - even missing - files are ignored in dry run")),
+	OPT_BOOL(0, "sparse", &include_sparse, N_("allow updating entries outside of the sparse-checkout cone")),
+	OPT_STRING(0, "chmod", &chmod_arg, "(+|-)x",
+		   N_("override the executable bit of the listed files")),
+	OPT_HIDDEN_BOOL(0, "warn-embedded-repo", &warn_on_embedded_repo,
+			N_("warn when adding an embedded repository")),
+	OPT_HIDDEN_BOOL(0, "legacy-stash-p", &legacy_stash_p,
+			N_("backend for `git stash -p`")),
+	OPT_PATHSPEC_FROM_FILE(&pathspec_from_file),
+	OPT_PATHSPEC_FILE_NUL(&pathspec_file_nul),
+	OPT_END(),
+};
+#endif
+
 	git_config(add_config, NULL);
 
 	argc = parse_options(argc, argv, prefix, builtin_add_options,
diff --git a/builtin/am.c b/builtin/am.c
index b6be1f1cb1..2459212833 100644
--- a/builtin/am.c
+++ b/builtin/am.c
@@ -35,6 +35,10 @@
 #include "packfile.h"
 #include "repository.h"
 
+#ifdef __VSF__
+# include "git_port_vsf.h"
+#endif
+
 /**
  * Returns the length of the first line of msg.
  */
@@ -1131,12 +1135,19 @@ static void am_next(struct am_state *state)
  */
 static const char *msgnum(const struct am_state *state)
 {
+#ifdef __VSF__
+# define sb (git_ctx->builtin_am.msgnum.__sb)
+#else
 	static struct strbuf sb = STRBUF_INIT;
+#endif
 
 	strbuf_reset(&sb);
 	strbuf_addf(&sb, "%0*d", state->prec, state->cur);
 
 	return sb.buf;
+#ifdef __VSF__
+# undef sb
+#endif
 }
 
 /**
diff --git a/builtin/blame.c b/builtin/blame.c
index 7fafeac408..05756ef4fe 100644
--- a/builtin/blame.c
+++ b/builtin/blame.c
@@ -29,6 +29,10 @@
 #include "refs.h"
 #include "tag.h"
 
+#ifdef __VSF__
+# include "git_port_vsf.h"
+#endif
+
 static char blame_usage[] = N_("git blame [<options>] [<rev-opts>] [<rev>] [--] <file>");
 
 static const char *blame_opt_usage[] = {
@@ -38,18 +42,41 @@ static const char *blame_opt_usage[] = {
 	NULL
 };
 
+#ifdef __VSF__
+# define longest_file (git_ctx->builtin_blame.__longest_file)
+# define longest_author (git_ctx->builtin_blame.__longest_author)
+# define max_orig_digits (git_ctx->builtin_blame.__max_orig_digits)
+# define max_digits (git_ctx->builtin_blame.__max_digits)
+# define max_score_digits (git_ctx->builtin_blame.__max_score_digits)
+# define __show_root (git_ctx->builtin_blame.__show_root)
+# define __reverse (git_ctx->builtin_blame.__reverse)
+# define blank_boundary (git_ctx->builtin_blame.__blank_boundary)
+# define incremental (git_ctx->builtin_blame.__incremental)
+# define __xdl_opts (git_ctx->builtin_blame.__xdl_opts)
+# define abbrev (git_ctx->builtin_blame.__abbrev)
+# define __no_whole_file_rename (git_ctx->builtin_blame.__no_whole_file_rename)
+# define show_progress (git_ctx->builtin_blame.__show_progress)
+# define repeated_meta_color (git_ctx->builtin_blame.__repeated_meta_color)
+# define coloring_mode (git_ctx->builtin_blame.__coloring_mode)
+# define ignore_revs_file_list (git_ctx->builtin_blame.__ignore_revs_file_list)
+# define mark_unblamable_lines (git_ctx->builtin_blame.__mark_unblamable_lines)
+# define mark_ignored_lines (git_ctx->builtin_blame.__mark_ignored_lines)
+# define blame_date_mode (git_ctx->builtin_blame.__blame_date_mode)
+# define blame_date_width (git_ctx->builtin_blame.__blame_date_width)
+# define mailmap (git_ctx->builtin_blame.__mailmap)
+#else
 static int longest_file;
 static int longest_author;
 static int max_orig_digits;
 static int max_digits;
 static int max_score_digits;
-static int show_root;
-static int reverse;
+static int __show_root;
+static int __reverse;
 static int blank_boundary;
 static int incremental;
-static int xdl_opts;
+static int __xdl_opts;
 static int abbrev = -1;
-static int no_whole_file_rename;
+static int __no_whole_file_rename;
 static int show_progress;
 static char repeated_meta_color[COLOR_MAXLEN];
 static int coloring_mode;
@@ -61,13 +88,19 @@ static struct date_mode blame_date_mode = { DATE_ISO8601 };
 static size_t blame_date_width;
 
 static struct string_list mailmap = STRING_LIST_INIT_NODUP;
+#endif
 
 #ifndef DEBUG_BLAME
 #define DEBUG_BLAME 0
 #endif
 
+#ifdef __VSF__
+# define blame_move_score (git_ctx->builtin_blame.__blame_move_score)
+# define blame_copy_score (git_ctx->builtin_blame.__blame_copy_score)
+#else
 static unsigned blame_move_score;
 static unsigned blame_copy_score;
+#endif
 
 /* Remember to update object flag allocation in object.h */
 #define METAINFO_SHOWN		(1u<<12)
@@ -291,7 +324,11 @@ static void found_guilty_entry(struct blame_entry *ent, void *data)
 static const char *format_time(timestamp_t time, const char *tz_str,
 			       int show_raw_time)
 {
+#ifdef __VSF__
+# define time_buf (git_ctx->builtin_blame.format_time.__time_buf)
+#else
 	static struct strbuf time_buf = STRBUF_INIT;
+#endif
 
 	strbuf_reset(&time_buf);
 	if (show_raw_time) {
@@ -314,6 +351,9 @@ static const char *format_time(timestamp_t time, const char *tz_str,
 			strbuf_addch(&time_buf, ' ');
 	}
 	return time_buf.buf;
+#ifdef __VSF__
+# undef time_buf
+#endif
 }
 
 #define OUTPUT_ANNOTATE_COMPAT      (1U<<0)
@@ -375,11 +415,17 @@ static void emit_porcelain(struct blame_scoreboard *sb, struct blame_entry *ent,
 		putchar('\n');
 }
 
+#ifdef __VSF__
+# define colorfield (git_ctx->builtin_blame.__colorfield)
+# define colorfield_nr (git_ctx->builtin_blame.__colorfield_nr)
+# define colorfield_alloc (git_ctx->builtin_blame.__colorfield_alloc)
+#else
 static struct color_field {
 	timestamp_t hop;
 	char col[COLOR_MAXLEN];
 } *colorfield;
 static int colorfield_nr, colorfield_alloc;
+#endif
 
 static void parse_color_fields(const char *s)
 {
@@ -680,7 +726,7 @@ static const char *add_prefix(const char *prefix, const char *path)
 static int git_blame_config(const char *var, const char *value, void *cb)
 {
 	if (!strcmp(var, "blame.showroot")) {
-		show_root = git_config_bool(var, value);
+		__show_root = git_config_bool(var, value);
 		return 0;
 	}
 	if (!strcmp(var, "blame.blankboundary")) {
@@ -821,14 +867,14 @@ static int peel_to_commit_oid(struct object_id *oid_ret, void *cbdata)
 }
 
 static void build_ignorelist(struct blame_scoreboard *sb,
-			     struct string_list *ignore_revs_file_list,
+			     struct string_list *__ignore_revs_file_list,
 			     struct string_list *ignore_rev_list)
 {
 	struct string_list_item *i;
 	struct object_id oid;
 
 	oidset_init(&sb->ignore_list, 0);
-	for_each_string_list_item(i, ignore_revs_file_list) {
+	for_each_string_list_item(i, __ignore_revs_file_list) {
 		if (!strcmp(i->string, ""))
 			oidset_clear(&sb->ignore_list);
 		else
@@ -862,7 +908,7 @@ int cmd_blame(int argc, const char **argv, const char *prefix)
 	const struct option options[] = {
 		OPT_BOOL(0, "incremental", &incremental, N_("show blame entries as we find them, incrementally")),
 		OPT_BOOL('b', NULL, &blank_boundary, N_("do not show object names of boundary commits (Default: off)")),
-		OPT_BOOL(0, "root", &show_root, N_("do not treat root commits as boundaries (Default: off)")),
+		OPT_BOOL(0, "root", &__show_root, N_("do not treat root commits as boundaries (Default: off)")),
 		OPT_BOOL(0, "show-stats", &show_stats, N_("show work cost statistics")),
 		OPT_BOOL(0, "progress", &show_progress, N_("force progress reporting")),
 		OPT_BIT(0, "score-debug", &output_option, N_("show output score for blame entries"), OUTPUT_SHOW_SCORE),
@@ -875,12 +921,12 @@ int cmd_blame(int argc, const char **argv, const char *prefix)
 		OPT_BIT('l', NULL, &output_option, N_("show long commit SHA1 (Default: off)"), OUTPUT_LONG_OBJECT_NAME),
 		OPT_BIT('s', NULL, &output_option, N_("suppress author name and timestamp (Default: off)"), OUTPUT_NO_AUTHOR),
 		OPT_BIT('e', "show-email", &output_option, N_("show author email instead of name (Default: off)"), OUTPUT_SHOW_EMAIL),
-		OPT_BIT('w', NULL, &xdl_opts, N_("ignore whitespace differences"), XDF_IGNORE_WHITESPACE),
+		OPT_BIT('w', NULL, &__xdl_opts, N_("ignore whitespace differences"), XDF_IGNORE_WHITESPACE),
 		OPT_STRING_LIST(0, "ignore-rev", &ignore_rev_list, N_("rev"), N_("ignore <rev> when blaming")),
 		OPT_STRING_LIST(0, "ignore-revs-file", &ignore_revs_file_list, N_("file"), N_("ignore revisions from <file>")),
 		OPT_BIT(0, "color-lines", &output_option, N_("color redundant metadata from previous line differently"), OUTPUT_COLOR_LINE),
 		OPT_BIT(0, "color-by-age", &output_option, N_("color lines by age"), OUTPUT_SHOW_AGE_WITH_COLOR),
-		OPT_BIT(0, "minimal", &xdl_opts, N_("spend extra cycles to find better match"), XDF_NEED_MINIMAL),
+		OPT_BIT(0, "minimal", &__xdl_opts, N_("spend extra cycles to find better match"), XDF_NEED_MINIMAL),
 		OPT_STRING('S', NULL, &revs_file, N_("file"), N_("use revisions from <file> instead of calling git-rev-list")),
 		OPT_STRING(0, "contents", &contents_from, N_("file"), N_("use <file>'s contents as the final image")),
 		OPT_CALLBACK_F('C', NULL, &opt, N_("score"), N_("find line copies within and across files"), PARSE_OPT_OPTARG, blame_copy_callback),
@@ -929,13 +975,13 @@ int cmd_blame(int argc, const char **argv, const char *prefix)
 
 		if (!strcmp(ctx.argv[0], "--reverse")) {
 			ctx.argv[0] = "--children";
-			reverse = 1;
+			__reverse = 1;
 		}
 		parse_revision_opt(&revs, &ctx, options, blame_opt_usage);
 	}
 parse_done:
-	no_whole_file_rename = !revs.diffopt.flags.follow_renames;
-	xdl_opts |= revs.diffopt.xdl_opts & XDF_INDENT_HEURISTIC;
+	__no_whole_file_rename = !revs.diffopt.flags.follow_renames;
+	__xdl_opts |= revs.diffopt.xdl_opts & XDF_INDENT_HEURISTIC;
 	revs.diffopt.flags.follow_renames = 0;
 	argc = parse_options_end(&ctx);
 
@@ -1081,7 +1127,7 @@ int cmd_blame(int argc, const char **argv, const char *prefix)
 	init_scoreboard(&sb);
 	sb.revs = &revs;
 	sb.contents_from = contents_from;
-	sb.reverse = reverse;
+	sb.reverse = __reverse;
 	sb.repo = the_repository;
 	sb.path = path;
 	build_ignorelist(&sb, &ignore_revs_file_list, &ignore_rev_list);
@@ -1147,9 +1193,9 @@ int cmd_blame(int argc, const char **argv, const char *prefix)
 	sb.debug = DEBUG_BLAME;
 	sb.on_sanity_fail = &sanity_check_on_fail;
 
-	sb.show_root = show_root;
-	sb.xdl_opts = xdl_opts;
-	sb.no_whole_file_rename = no_whole_file_rename;
+	sb.show_root = __show_root;
+	sb.xdl_opts = __xdl_opts;
+	sb.no_whole_file_rename = __no_whole_file_rename;
 
 	read_mailmap(&mailmap);
 
diff --git a/builtin/branch.c b/builtin/branch.c
index 4ce2a24754..b557f1810a 100644
--- a/builtin/branch.c
+++ b/builtin/branch.c
@@ -25,6 +25,10 @@
 #include "help.h"
 #include "commit-reach.h"
 
+#ifdef __VSF__
+# include "git_port_vsf.h"
+#endif
+
 static const char * const builtin_branch_usage[] = {
 	N_("git branch [<options>] [-r | -a] [--merged] [--no-merged]"),
 	N_("git branch [<options>] [-l] [-f] <branch-name> [<start-point>]"),
@@ -36,11 +40,17 @@ static const char * const builtin_branch_usage[] = {
 	NULL
 };
 
+#ifdef __VSF__
+# define head (git_ctx->builtin_branch.__head)
+# define head_oid (git_ctx->builtin_branch.__head_oid)
+# define branch_use_color (git_ctx->builtin_branch.__branch_use_color)
+#else
 static const char *head;
 static struct object_id head_oid;
 
 static int branch_use_color = -1;
-static char branch_colors[][COLOR_MAXLEN] = {
+#endif
+static const char branch_colors[][COLOR_MAXLEN] = {
 	GIT_COLOR_RESET,
 	GIT_COLOR_NORMAL,       /* PLAIN */
 	GIT_COLOR_RED,          /* REMOTE */
@@ -69,8 +79,13 @@ static const char *color_branch_slots[] = {
 	[BRANCH_COLOR_WORKTREE] = "worktree",
 };
 
-static struct string_list output = STRING_LIST_INIT_DUP;
+#ifdef __VSF__
+# define __output (git_ctx->builtin_branch.__output)
+# define colopts (git_ctx->builtin_branch.__colopts)
+#else
+static struct string_list __output = STRING_LIST_INIT_DUP;
 static unsigned int colopts;
+#endif
 
 define_list_config_array(color_branch_slots);
 
@@ -335,21 +350,28 @@ static int calc_maxwidth(struct ref_array *refs, int remote_bonus)
 
 static const char *quote_literal_for_format(const char *s)
 {
-	static struct strbuf buf = STRBUF_INIT;
+#ifdef __VSF__
+# define __buf (git_ctx->builtin_branch.quote_literal_for_format.__buf)
+#else
+	static struct strbuf __buf = STRBUF_INIT;
+#endif
 
-	strbuf_reset(&buf);
+	strbuf_reset(&__buf);
 	while (*s) {
 		const char *ep = strchrnul(s, '%');
 		if (s < ep)
-			strbuf_add(&buf, s, ep - s);
+			strbuf_add(&__buf, s, ep - s);
 		if (*ep == '%') {
-			strbuf_addstr(&buf, "%%");
+			strbuf_addstr(&__buf, "%%");
 			s = ep + 1;
 		} else {
 			s = ep;
 		}
 	}
-	return buf.buf;
+	return __buf.buf;
+#ifdef __VSF__
+# undef __buf
+#endif
 }
 
 static char *build_format(struct ref_filter *filter, int maxwidth, const char *remote_prefix)
@@ -629,7 +651,11 @@ int cmd_branch(int argc, const char **argv, const char *prefix)
 	enum branch_track track;
 	struct ref_filter filter;
 	int icase = 0;
+#ifdef __VSF__
+# define sorting (git_ctx->builtin_branch.cmd_branch.__sorting)
+#else
 	static struct ref_sorting *sorting;
+#endif
 	struct string_list sorting_options = STRING_LIST_INIT_DUP;
 	struct ref_format format = REF_FORMAT_INIT;
 
@@ -760,9 +786,9 @@ int cmd_branch(int argc, const char **argv, const char *prefix)
 		ref_sorting_set_sort_flags_all(sorting, REF_SORTING_ICASE, icase);
 		ref_sorting_set_sort_flags_all(
 			sorting, REF_SORTING_DETACHED_HEAD_FIRST, 1);
-		print_ref_list(&filter, sorting, &format, &output);
-		print_columns(&output, colopts, NULL);
-		string_list_clear(&output, 0);
+		print_ref_list(&filter, sorting, &format, &__output);
+		print_columns(&__output, colopts, NULL);
+		string_list_clear(&__output, 0);
 		ref_sorting_release(sorting);
 		return 0;
 	} else if (edit_description) {
@@ -873,4 +899,7 @@ int cmd_branch(int argc, const char **argv, const char *prefix)
 		usage_with_options(builtin_branch_usage, options);
 
 	return 0;
+#ifdef __VSF__
+# undef sorting
+#endif
 }
diff --git a/builtin/cat-file.c b/builtin/cat-file.c
index d94050e6c1..5d4ab02f28 100644
--- a/builtin/cat-file.c
+++ b/builtin/cat-file.c
@@ -17,6 +17,10 @@
 #include "object-store.h"
 #include "promisor-remote.h"
 
+#ifdef __VSF__
+# include "git_port_vsf.h"
+#endif
+
 struct batch_options {
 	int enabled;
 	int follow_symlinks;
@@ -28,7 +32,11 @@ struct batch_options {
 	const char *format;
 };
 
+#ifdef __VSF__
+# define force_path (git_ctx->builtin_cat_file.__force_path)
+#else
 static const char *force_path;
+#endif
 
 static int filter_object(const char *path, unsigned mode,
 			 const struct object_id *oid,
diff --git a/builtin/check-attr.c b/builtin/check-attr.c
index dd83397786..1d677d0637 100644
--- a/builtin/check-attr.c
+++ b/builtin/check-attr.c
@@ -6,15 +6,29 @@
 #include "quote.h"
 #include "parse-options.h"
 
+#ifdef __VSF__
+# include "git_port_vsf.h"
+#endif
+
+#ifdef __VSF__
+# define all_attrs (git_ctx->builtin_check_attr.__all_attrs)
+# define cached_attrs (git_ctx->builtin_check_attr.__cached_attrs)
+# define stdin_paths (git_ctx->builtin_check_attr.__stdin_paths)
+#else
 static int all_attrs;
 static int cached_attrs;
 static int stdin_paths;
+#endif
 static const char * const check_attr_usage[] = {
 N_("git check-attr [-a | --all | <attr>...] [--] <pathname>..."),
 N_("git check-attr --stdin [-z] [-a | --all | <attr>...]"),
 NULL
 };
 
+#ifdef __VSF__
+# define nul_term_line (git_ctx->builtin_check_attr.__nul_term_line)
+# define check_attr_options (git_ctx->builtin_check_attr.__check_attr_options)
+#else
 static int nul_term_line;
 
 static const struct option check_attr_options[] = {
@@ -25,6 +39,7 @@ static const struct option check_attr_options[] = {
 		 N_("terminate input and output records by a NUL character")),
 	OPT_END()
 };
+#endif
 
 static void output_attr(struct attr_check *check, const char *file)
 {
diff --git a/builtin/check-ignore.c b/builtin/check-ignore.c
index 2191256965..21ea328d86 100644
--- a/builtin/check-ignore.c
+++ b/builtin/check-ignore.c
@@ -8,13 +8,28 @@
 #include "parse-options.h"
 #include "submodule.h"
 
+#ifdef __VSF__
+# include "git_port_vsf.h"
+#endif
+
+#ifdef __VSF__
+# define quiet (git_ctx->builtin_check_ignore.__quiet)
+# define verbose (git_ctx->builtin_check_ignore.__verbose)
+# define stdin_paths (git_ctx->builtin_check_ignore.__stdin_paths)
+# define show_non_matching (git_ctx->builtin_check_ignore.__show_non_matching)
+# define no_index (git_ctx->builtin_check_ignore.__no_index)
+#else
 static int quiet, verbose, stdin_paths, show_non_matching, no_index;
+#endif
 static const char * const check_ignore_usage[] = {
 "git check-ignore [<options>] <pathname>...",
 "git check-ignore [<options>] --stdin",
 NULL
 };
 
+#ifdef __VSF__
+# define nul_term_line (git_ctx->builtin_check_ignore.__nul_term_line)
+#else
 static int nul_term_line;
 
 static const struct option check_ignore_options[] = {
@@ -31,6 +46,7 @@ static const struct option check_ignore_options[] = {
 		 N_("ignore index when checking")),
 	OPT_END()
 };
+#endif
 
 static void output_pattern(const char *path, struct path_pattern *pattern)
 {
@@ -155,6 +171,23 @@ int cmd_check_ignore(int argc, const char **argv, const char *prefix)
 	int num_ignored;
 	struct dir_struct dir = DIR_INIT;
 
+#ifdef __VSF__
+struct option check_ignore_options[] = {
+	OPT__QUIET(&quiet, N_("suppress progress reporting")),
+	OPT__VERBOSE(&verbose, N_("be verbose")),
+	OPT_GROUP(""),
+	OPT_BOOL(0, "stdin", &stdin_paths,
+		 N_("read file names from stdin")),
+	OPT_BOOL('z', NULL, &nul_term_line,
+		 N_("terminate input and output records by a NUL character")),
+	OPT_BOOL('n', "non-matching", &show_non_matching,
+		 N_("show non-matching input paths")),
+	OPT_BOOL(0, "no-index", &no_index,
+		 N_("ignore index when checking")),
+	OPT_END()
+};
+#endif
+
 	git_config(git_default_config, NULL);
 
 	argc = parse_options(argc, argv, prefix, check_ignore_options,
diff --git a/builtin/check-mailmap.c b/builtin/check-mailmap.c
index 7dc47e4793..f151950459 100644
--- a/builtin/check-mailmap.c
+++ b/builtin/check-mailmap.c
@@ -4,16 +4,26 @@
 #include "parse-options.h"
 #include "string-list.h"
 
+#ifdef __VSF__
+# include "git_port_vsf.h"
+#endif
+
+#ifdef __VSF__
+# define use_stdin (git_ctx->builtin_check_mailmap.__use_stdin)
+#else
 static int use_stdin;
+#endif
 static const char * const check_mailmap_usage[] = {
 N_("git check-mailmap [<options>] <contact>..."),
 NULL
 };
 
+#ifndef __VSF__
 static const struct option check_mailmap_options[] = {
 	OPT_BOOL(0, "stdin", &use_stdin, N_("also read contacts from stdin")),
 	OPT_END()
 };
+#endif
 
 static void check_mailmap(struct string_list *mailmap, const char *contact)
 {
@@ -41,6 +51,13 @@ int cmd_check_mailmap(int argc, const char **argv, const char *prefix)
 	int i;
 	struct string_list mailmap = STRING_LIST_INIT_NODUP;
 
+#ifdef __VSF__
+struct option check_mailmap_options[] = {
+	OPT_BOOL(0, "stdin", &use_stdin, N_("also read contacts from stdin")),
+	OPT_END()
+};
+#endif
+
 	git_config(git_default_config, NULL);
 	argc = parse_options(argc, argv, prefix, check_mailmap_options,
 			     check_mailmap_usage, 0);
diff --git a/builtin/checkout-index.c b/builtin/checkout-index.c
index e21620d964..c723d14f80 100644
--- a/builtin/checkout-index.c
+++ b/builtin/checkout-index.c
@@ -14,6 +14,17 @@
 #include "entry.h"
 #include "parallel-checkout.h"
 
+#ifdef __VSF__
+# include "git_port_vsf.h"
+#endif
+
+#ifdef __VSF__
+# define nul_term_line (git_ctx->builtin_checkout_index.__nul_term_line)
+# define checkout_stage (git_ctx->builtin_checkout_index.__checkout_stage)
+# define to_tempfile (git_ctx->builtin_checkout_index.__to_tempfile)
+# define topath (git_ctx->builtin_checkout_index.__topath)
+# define state (git_ctx->builtin_checkout_index.__state)
+#else
 #define CHECKOUT_ALL 4
 static int nul_term_line;
 static int checkout_stage; /* default to checkout stage0 */
@@ -21,6 +32,7 @@ static int to_tempfile;
 static char topath[4][TEMPORARY_FILENAME_LENGTH + 1];
 
 static struct checkout state = CHECKOUT_INIT;
+#endif
 
 static void write_tempfile_record(const char *name, const char *prefix)
 {
diff --git a/builtin/checkout.c b/builtin/checkout.c
index cc804ba8e1..a3ba289b63 100644
--- a/builtin/checkout.c
+++ b/builtin/checkout.c
@@ -29,6 +29,10 @@
 #include "entry.h"
 #include "parallel-checkout.h"
 
+#ifdef __VSF__
+# include "git_port_vsf.h"
+#endif
+
 static const char * const checkout_usage[] = {
 	N_("git checkout [<options>] <branch>"),
 	N_("git checkout [<options>] [<branch>] -- <file>..."),
@@ -1587,8 +1591,12 @@ static struct option *add_checkout_path_options(struct checkout_opts *opts,
 	return newopts;
 }
 
+#ifdef __VSF__
+# define cb_option (git_ctx->builtin_checkout.__cb_option)
+#else
 /* create-branch option (either b or c) */
 static char cb_option = 'b';
+#endif
 
 static int checkout_main(int argc, const char **argv, const char *prefix,
 			 struct checkout_opts *opts, struct option *options,
diff --git a/builtin/clean.c b/builtin/clean.c
index 3ff02bbbff..745d4df000 100644
--- a/builtin/clean.c
+++ b/builtin/clean.c
@@ -20,10 +20,21 @@
 #include "help.h"
 #include "prompt.h"
 
+#ifdef __VSF__
+# include "git_port_vsf.h"
+#endif
+
+#ifdef __VSF__
+# define force (git_ctx->builtin_clean.__force)
+# define interactive (git_ctx->builtin_clean.__interactive)
+# define del_list (git_ctx->builtin_clean.__del_list)
+# define colopts (git_ctx->builtin_clean.__colopts)
+#else
 static int force = -1; /* unset */
 static int interactive;
 static struct string_list del_list = STRING_LIST_INIT_DUP;
 static unsigned int colopts;
+#endif
 
 static const char *const builtin_clean_usage[] = {
 	N_("git clean [-d] [-f] [-i] [-n] [-q] [-e <pattern>] [-x | -X] [--] <paths>..."),
@@ -57,8 +68,12 @@ static const char *color_interactive_slots[] = {
 	[CLEAN_COLOR_RESET]  = "reset",
 };
 
+#ifdef __VSF__
+# define clean_use_color (git_ctx->builtin_clean.__clean_use_color)
+#else
 static int clean_use_color = -1;
-static char clean_colors[][COLOR_MAXLEN] = {
+#endif
+static const char clean_colors[][COLOR_MAXLEN] = {
 	[CLEAN_COLOR_ERROR] = GIT_COLOR_BOLD_RED,
 	[CLEAN_COLOR_HEADER] = GIT_COLOR_BOLD,
 	[CLEAN_COLOR_HELP] = GIT_COLOR_BOLD_RED,
diff --git a/builtin/clone.c b/builtin/clone.c
index 727e16e0ae..8125b17446 100644
--- a/builtin/clone.c
+++ b/builtin/clone.c
@@ -33,6 +33,10 @@
 #include "packfile.h"
 #include "list-objects-filter-options.h"
 
+#ifdef __VSF__
+# include "git_port_vsf.h"
+#endif
+
 /*
  * Overall FIXMEs:
  *  - respect DB_ENVIRONMENT for .git/objects.
@@ -46,6 +50,42 @@ static const char * const builtin_clone_usage[] = {
 	NULL
 };
 
+#ifdef __VSF__
+# define option_no_checkout (git_ctx->builtin_clone.__option_no_checkout)
+# define option_bare (git_ctx->builtin_clone.__option_bare)
+# define option_mirror (git_ctx->builtin_clone.__option_mirror)
+# define option_single_branch (git_ctx->builtin_clone.__option_single_branch)
+# define option_local (git_ctx->builtin_clone.__option_local)
+# define option_no_hardlinks (git_ctx->builtin_clone.__option_no_hardlinks)
+# define option_shared (git_ctx->builtin_clone.__option_shared)
+# define option_no_tags (git_ctx->builtin_clone.__option_no_tags)
+# define option_shallow_submodules (git_ctx->builtin_clone.__option_shallow_submodules)
+# define option_reject_shallow (git_ctx->builtin_clone.__option_reject_shallow)
+# define config_reject_shallow (git_ctx->builtin_clone.__config_reject_shallow)
+# define deepen (git_ctx->builtin_clone.__deepen)
+# define option_template (git_ctx->builtin_clone.__option_template)
+# define option_depth (git_ctx->builtin_clone.__option_depth)
+# define option_since (git_ctx->builtin_clone.__option_since)
+# define option_origin (git_ctx->builtin_clone.__option_origin)
+# define remote_name (git_ctx->builtin_clone.__remote_name)
+# define option_branch (git_ctx->builtin_clone.__option_branch)
+# define option_not (git_ctx->builtin_clone.__option_not)
+# define real_git_dir (git_ctx->builtin_clone.__real_git_dir)
+# define option_upload_pack (git_ctx->builtin_clone.__option_upload_pack)
+# define option_verbosity (git_ctx->builtin_clone.__option_verbosity)
+# define option_progress (git_ctx->builtin_clone.__option_progress)
+# define option_sparse_checkout (git_ctx->builtin_clone.__option_sparse_checkout)
+# define __family (git_ctx->builtin_clone.__family)
+# define option_config (git_ctx->builtin_clone.__option_config)
+# define option_required_reference (git_ctx->builtin_clone.__option_required_reference)
+# define option_optional_reference (git_ctx->builtin_clone.__option_optional_reference)
+# define option_dissociate (git_ctx->builtin_clone.__option_dissociate)
+# define max_jobs (git_ctx->builtin_clone.__max_jobs)
+# define option_recurse_submodules (git_ctx->builtin_clone.__option_recurse_submodules)
+# define filter_options (git_ctx->builtin_clone.__filter_options)
+# define __server_options (git_ctx->builtin_clone.__server_options)
+# define option_remote_submodules (git_ctx->builtin_clone.__option_remote_submodules)
+#else
 static int option_no_checkout, option_bare, option_mirror, option_single_branch = -1;
 static int option_local = -1, option_no_hardlinks, option_shared;
 static int option_no_tags;
@@ -63,7 +103,7 @@ static char *option_upload_pack = "git-upload-pack";
 static int option_verbosity;
 static int option_progress = -1;
 static int option_sparse_checkout;
-static enum transport_family family;
+static enum transport_family __family;
 static struct string_list option_config = STRING_LIST_INIT_NODUP;
 static struct string_list option_required_reference = STRING_LIST_INIT_NODUP;
 static struct string_list option_optional_reference = STRING_LIST_INIT_NODUP;
@@ -71,8 +111,9 @@ static int option_dissociate;
 static int max_jobs = -1;
 static struct string_list option_recurse_submodules = STRING_LIST_INIT_NODUP;
 static struct list_objects_filter_options filter_options;
-static struct string_list server_options = STRING_LIST_INIT_NODUP;
+static struct string_list __server_options = STRING_LIST_INIT_NODUP;
 static int option_remote_submodules;
+#endif
 
 static int recurse_submodules_cb(const struct option *opt,
 				 const char *arg, int unset)
@@ -88,6 +129,7 @@ static int recurse_submodules_cb(const struct option *opt,
 	return 0;
 }
 
+#ifndef __VSF__
 static struct option builtin_clone_options[] = {
 	OPT__VERBOSITY(&option_verbosity),
 	OPT_BOOL(0, "progress", &option_progress,
@@ -143,11 +185,11 @@ static struct option builtin_clone_options[] = {
 		   N_("separate git dir from working tree")),
 	OPT_STRING_LIST('c', "config", &option_config, N_("key=value"),
 			N_("set config inside the new repository")),
-	OPT_STRING_LIST(0, "server-option", &server_options,
+	OPT_STRING_LIST(0, "server-option", &__server_options,
 			N_("server-specific"), N_("option to transmit")),
-	OPT_SET_INT('4', "ipv4", &family, N_("use IPv4 addresses only"),
+	OPT_SET_INT('4', "ipv4", &__family, N_("use IPv4 addresses only"),
 			TRANSPORT_FAMILY_IPV4),
-	OPT_SET_INT('6', "ipv6", &family, N_("use IPv6 addresses only"),
+	OPT_SET_INT('6', "ipv6", &__family, N_("use IPv6 addresses only"),
 			TRANSPORT_FAMILY_IPV6),
 	OPT_PARSE_LIST_OBJECTS_FILTER(&filter_options),
 	OPT_BOOL(0, "remote-submodules", &option_remote_submodules,
@@ -156,11 +198,12 @@ static struct option builtin_clone_options[] = {
 		    N_("initialize sparse-checkout file to include only files at root")),
 	OPT_END()
 };
+#endif
 
 static const char *get_repo_path_1(struct strbuf *path, int *is_bundle)
 {
-	static char *suffix[] = { "/.git", "", ".git/.git", ".git" };
-	static char *bundle_suffix[] = { ".bundle", "" };
+	static const char * const suffix[] = { "/.git", "", ".git/.git", ".git" };
+	static const char * const bundle_suffix[] = { ".bundle", "" };
 	size_t baselen = path->len;
 	struct stat st;
 	int i;
@@ -389,6 +432,13 @@ static void clone_local(const char *src_repo, const char *dest_repo)
 		fprintf(stderr, _("done.\n"));
 }
 
+#ifdef __VSF__
+# define junk_work_tree (git_ctx->builtin_clone.__junk_work_tree)
+# define junk_work_tree_flags (git_ctx->builtin_clone.__junk_work_tree_flags)
+# define junk_git_dir (git_ctx->builtin_clone.__junk_git_dir)
+# define junk_git_dir_flags (git_ctx->builtin_clone.__junk_git_dir_flags)
+# define junk_mode (git_ctx->builtin_clone.__junk_mode)
+#else
 static const char *junk_work_tree;
 static int junk_work_tree_flags;
 static const char *junk_git_dir;
@@ -398,6 +448,7 @@ static enum {
 	JUNK_LEAVE_REPO,
 	JUNK_LEAVE_ALL
 } junk_mode = JUNK_LEAVE_NONE;
+#endif
 
 static const char junk_leave_repo_msg[] =
 N_("Clone succeeded, but checkout failed.\n"
@@ -875,6 +926,77 @@ int cmd_clone(int argc, const char **argv, const char *prefix)
 	struct transport_ls_refs_options transport_ls_refs_options =
 		TRANSPORT_LS_REFS_OPTIONS_INIT;
 
+#ifdef __VSF__
+struct option builtin_clone_options[] = {
+	OPT__VERBOSITY(&option_verbosity),
+	OPT_BOOL(0, "progress", &option_progress,
+		 N_("force progress reporting")),
+	OPT_BOOL(0, "reject-shallow", &option_reject_shallow,
+		 N_("don't clone shallow repository")),
+	OPT_BOOL('n', "no-checkout", &option_no_checkout,
+		 N_("don't create a checkout")),
+	OPT_BOOL(0, "bare", &option_bare, N_("create a bare repository")),
+	OPT_HIDDEN_BOOL(0, "naked", &option_bare,
+			N_("create a bare repository")),
+	OPT_BOOL(0, "mirror", &option_mirror,
+		 N_("create a mirror repository (implies bare)")),
+	OPT_BOOL('l', "local", &option_local,
+		N_("to clone from a local repository")),
+	OPT_BOOL(0, "no-hardlinks", &option_no_hardlinks,
+		    N_("don't use local hardlinks, always copy")),
+	OPT_BOOL('s', "shared", &option_shared,
+		    N_("setup as shared repository")),
+	{ OPTION_CALLBACK, 0, "recurse-submodules", &option_recurse_submodules,
+	  N_("pathspec"), N_("initialize submodules in the clone"),
+	  PARSE_OPT_OPTARG, recurse_submodules_cb, (intptr_t)"." },
+	OPT_ALIAS(0, "recursive", "recurse-submodules"),
+	OPT_INTEGER('j', "jobs", &max_jobs,
+		    N_("number of submodules cloned in parallel")),
+	OPT_STRING(0, "template", &option_template, N_("template-directory"),
+		   N_("directory from which templates will be used")),
+	OPT_STRING_LIST(0, "reference", &option_required_reference, N_("repo"),
+			N_("reference repository")),
+	OPT_STRING_LIST(0, "reference-if-able", &option_optional_reference,
+			N_("repo"), N_("reference repository")),
+	OPT_BOOL(0, "dissociate", &option_dissociate,
+		 N_("use --reference only while cloning")),
+	OPT_STRING('o', "origin", &option_origin, N_("name"),
+		   N_("use <name> instead of 'origin' to track upstream")),
+	OPT_STRING('b', "branch", &option_branch, N_("branch"),
+		   N_("checkout <branch> instead of the remote's HEAD")),
+	OPT_STRING('u', "upload-pack", &option_upload_pack, N_("path"),
+		   N_("path to git-upload-pack on the remote")),
+	OPT_STRING(0, "depth", &option_depth, N_("depth"),
+		    N_("create a shallow clone of that depth")),
+	OPT_STRING(0, "shallow-since", &option_since, N_("time"),
+		    N_("create a shallow clone since a specific time")),
+	OPT_STRING_LIST(0, "shallow-exclude", &option_not, N_("revision"),
+			N_("deepen history of shallow clone, excluding rev")),
+	OPT_BOOL(0, "single-branch", &option_single_branch,
+		    N_("clone only one branch, HEAD or --branch")),
+	OPT_BOOL(0, "no-tags", &option_no_tags,
+		 N_("don't clone any tags, and make later fetches not to follow them")),
+	OPT_BOOL(0, "shallow-submodules", &option_shallow_submodules,
+		    N_("any cloned submodules will be shallow")),
+	OPT_STRING(0, "separate-git-dir", &real_git_dir, N_("gitdir"),
+		   N_("separate git dir from working tree")),
+	OPT_STRING_LIST('c', "config", &option_config, N_("key=value"),
+			N_("set config inside the new repository")),
+	OPT_STRING_LIST(0, "server-option", &__server_options,
+			N_("server-specific"), N_("option to transmit")),
+	OPT_SET_INT('4', "ipv4", &__family, N_("use IPv4 addresses only"),
+			TRANSPORT_FAMILY_IPV4),
+	OPT_SET_INT('6', "ipv6", &__family, N_("use IPv6 addresses only"),
+			TRANSPORT_FAMILY_IPV6),
+	OPT_PARSE_LIST_OBJECTS_FILTER(&filter_options),
+	OPT_BOOL(0, "remote-submodules", &option_remote_submodules,
+		    N_("any cloned submodules will use their remote-tracking branch")),
+	OPT_BOOL(0, "sparse", &option_sparse_checkout,
+		    N_("initialize sparse-checkout file to include only files at root")),
+	OPT_END()
+};
+#endif
+
 	packet_trace_identity("clone");
 
 	git_config(git_clone_config, NULL);
@@ -1112,7 +1234,7 @@ int cmd_clone(int argc, const char **argv, const char *prefix)
 
 	transport = transport_get(remote, remote->url[0]);
 	transport_set_verbosity(transport, option_verbosity, option_progress);
-	transport->family = family;
+	transport->family = __family;
 
 	path = get_repo_path(remote->url[0], &is_bundle);
 	is_local = option_local != 0 && path && !is_bundle;
@@ -1157,8 +1279,8 @@ int cmd_clone(int argc, const char **argv, const char *prefix)
 		transport_set_option(transport, TRANS_OPT_UPLOADPACK,
 				     option_upload_pack);
 
-	if (server_options.nr)
-		transport->server_options = &server_options;
+	if (__server_options.nr)
+		transport->server_options = &__server_options;
 
 	if (filter_options.choice) {
 		const char *spec =
diff --git a/builtin/column.c b/builtin/column.c
index 158fdf53d9..0d31fa0365 100644
--- a/builtin/column.c
+++ b/builtin/column.c
@@ -6,11 +6,19 @@
 #include "string-list.h"
 #include "column.h"
 
+#ifdef __VSF__
+# include "git_port_vsf.h"
+#endif
+
 static const char * const builtin_column_usage[] = {
 	N_("git column [<options>]"),
 	NULL
 };
+#ifdef __VSF__
+# define colopts (git_ctx->builtin_column.__colopts)
+#else
 static unsigned int colopts;
+#endif
 
 static int column_config(const char *var, const char *value, void *cb)
 {
diff --git a/builtin/commit-graph.c b/builtin/commit-graph.c
index 4247fbde95..6fc0e652f3 100644
--- a/builtin/commit-graph.c
+++ b/builtin/commit-graph.c
@@ -9,6 +9,10 @@
 #include "progress.h"
 #include "tag.h"
 
+#ifdef __VSF__
+# include "git_port_vsf.h"
+#endif
+
 #define BUILTIN_COMMIT_GRAPH_VERIFY_USAGE \
 	N_("git commit-graph verify [--object-dir <objdir>] [--shallow] [--[no-]progress]")
 
@@ -18,12 +22,12 @@
 	   "[--changed-paths] [--[no-]max-new-filters <n>] [--[no-]progress] " \
 	   "<split options>")
 
-static const char * builtin_commit_graph_verify_usage[] = {
+static const char * const builtin_commit_graph_verify_usage[] = {
 	BUILTIN_COMMIT_GRAPH_VERIFY_USAGE,
 	NULL
 };
 
-static const char * builtin_commit_graph_write_usage[] = {
+static const char * const builtin_commit_graph_write_usage[] = {
 	BUILTIN_COMMIT_GRAPH_WRITE_USAGE,
 	NULL
 };
@@ -34,6 +38,10 @@ static char const * const builtin_commit_graph_usage[] = {
 	NULL,
 };
 
+#ifdef __VSF__
+# define opts (git_ctx->builtin_commit_graph.__opts)
+# define common_opts (git_ctx->builtin_commit_graph.__common_opts)
+#else
 static struct opts_commit_graph {
 	const char *obj_dir;
 	int reachable;
@@ -52,6 +60,7 @@ static struct option common_opts[] = {
 		   N_("the object directory to store the graph")),
 	OPT_END()
 };
+#endif
 
 static struct option *add_common_options(struct option *to)
 {
@@ -68,7 +77,7 @@ static int graph_verify(int argc, const char **argv)
 	struct stat st;
 	int flags = 0;
 
-	static struct option builtin_commit_graph_verify_options[] = {
+	struct option builtin_commit_graph_verify_options[] = {
 		OPT_BOOL(0, "shallow", &opts.shallow,
 			 N_("if the commit-graph is split, only verify the tip file")),
 		OPT_BOOL(0, "progress", &opts.progress,
@@ -115,8 +124,13 @@ static int graph_verify(int argc, const char **argv)
 	return verify_commit_graph(the_repository, graph, flags);
 }
 
+#ifdef __VSF__
+# define read_replace_refs (git_ctx->builtin_commit_graph.__read_replace_refs)
+# define write_opts (git_ctx->builtin_commit_graph.__write_opts)
+#else
 extern int read_replace_refs;
 static struct commit_graph_opts write_opts;
+#endif
 
 static int write_option_parse_split(const struct option *opt, const char *arg,
 				    int unset)
@@ -200,7 +214,7 @@ static int graph_write(int argc, const char **argv)
 	enum commit_graph_write_flags flags = 0;
 	struct progress *progress = NULL;
 
-	static struct option builtin_commit_graph_write_options[] = {
+	struct option builtin_commit_graph_write_options[] = {
 		OPT_BOOL(0, "reachable", &opts.reachable,
 			N_("start walk at all refs")),
 		OPT_BOOL(0, "stdin-packs", &opts.stdin_packs,
diff --git a/builtin/commit-tree.c b/builtin/commit-tree.c
index 63ea322933..e7bb3089de 100644
--- a/builtin/commit-tree.c
+++ b/builtin/commit-tree.c
@@ -14,13 +14,21 @@
 #include "gpg-interface.h"
 #include "parse-options.h"
 
+#ifdef __VSF__
+# include "git_port_vsf.h"
+#endif
+
 static const char * const commit_tree_usage[] = {
 	N_("git commit-tree [(-p <parent>)...] [-S[<keyid>]] [(-m <message>)...] "
 		"[(-F <file>)...] <tree>"),
 	NULL
 };
 
+#ifdef __VSF__
+# define sign_commit (git_ctx->builtin_commit_tree.__sign_commit)
+#else
 static const char *sign_commit;
+#endif
 
 static void new_parent(struct commit *parent, struct commit_list **parents_p)
 {
@@ -100,7 +108,11 @@ static int parse_file_arg_callback(const struct option *opt,
 
 int cmd_commit_tree(int argc, const char **argv, const char *prefix)
 {
+#ifdef __VSF__
+# define buffer (git_ctx->builtin_commit_tree.cmd_commit_tree.__buffer)
+#else
 	static struct strbuf buffer = STRBUF_INIT;
+#endif
 	struct commit_list *parents = NULL;
 	struct object_id tree_oid;
 	struct object_id commit_oid;
diff --git a/builtin/commit.c b/builtin/commit.c
index b9ed0374e3..9ddbd11d86 100644
--- a/builtin/commit.c
+++ b/builtin/commit.c
@@ -38,6 +38,10 @@
 #include "commit-reach.h"
 #include "commit-graph.h"
 
+#ifdef __VSF__
+# include "git_port_vsf.h"
+#endif
+
 static const char * const builtin_commit_usage[] = {
 	N_("git commit [<options>] [--] <pathspec>..."),
 	NULL
@@ -89,6 +93,56 @@ static const char *color_status_slots[] = {
 	[WT_STATUS_ONBRANCH]	  = "branch",
 };
 
+#ifdef __VSF__
+# define use_message_buffer (git_ctx->builtin_commit.__use_message_buffer)
+# define index_lock (git_ctx->builtin_commit.__index_lock)
+# define false_lock (git_ctx->builtin_commit.__false_lock)
+# define commit_style (git_ctx->builtin_commit.__commit_style)
+# define logfile (git_ctx->builtin_commit.__logfile)
+# define force_author (git_ctx->builtin_commit.__force_author)
+# define template_file (git_ctx->builtin_commit.__template_file)
+# define author_message (git_ctx->builtin_commit.__author_message)
+# define author_message_buffer (git_ctx->builtin_commit.__author_message_buffer)
+# define edit_message (git_ctx->builtin_commit.__edit_message)
+# define use_message (git_ctx->builtin_commit.__use_message)
+# define fixup_message (git_ctx->builtin_commit.__fixup_message)
+# define fixup_commit (git_ctx->builtin_commit.__fixup_commit)
+# define squash_message (git_ctx->builtin_commit.__squash_message)
+# define fixup_prefix (git_ctx->builtin_commit.__fixup_prefix)
+# define all (git_ctx->builtin_commit.__all)
+# define also (git_ctx->builtin_commit.__also)
+# define interactive (git_ctx->builtin_commit.__interactive)
+# define patch_interactive (git_ctx->builtin_commit.__patch_interactive)
+# define only (git_ctx->builtin_commit.__only)
+# define __amend (git_ctx->builtin_commit.__amend)
+# define signoff (git_ctx->builtin_commit.__signoff)
+# define edit_flag (git_ctx->builtin_commit.__edit_flag)
+# define quiet (git_ctx->builtin_commit.__quiet)
+# define __verbose (git_ctx->builtin_commit.__verbose)
+# define no_verify (git_ctx->builtin_commit.__no_verify)
+# define allow_empty (git_ctx->builtin_commit.__allow_empty)
+# define dry_run (git_ctx->builtin_commit.__dry_run)
+# define renew_authorship (git_ctx->builtin_commit.__renew_authorship)
+# define config_commit_verbose (git_ctx->builtin_commit.__config_commit_verbose)
+# define no_post_rewrite (git_ctx->builtin_commit.__no_post_rewrite)
+# define allow_empty_message (git_ctx->builtin_commit.__allow_empty_message)
+# define pathspec_file_nul (git_ctx->builtin_commit.__pathspec_file_nul)
+# define untracked_files_arg (git_ctx->builtin_commit.__untracked_files_arg)
+# define force_date (git_ctx->builtin_commit.__force_date)
+# define __ignore_submodule_arg (git_ctx->builtin_commit.__ignore_submodule_arg)
+# define ignored_arg (git_ctx->builtin_commit.__ignored_arg)
+# define sign_commit (git_ctx->builtin_commit.__sign_commit)
+# define pathspec_from_file (git_ctx->builtin_commit.__pathspec_from_file)
+# define trailer_args (git_ctx->builtin_commit.__trailer_args)
+# define cleanup_mode (git_ctx->builtin_commit.__cleanup_mode)
+# define cleanup_arg (git_ctx->builtin_commit.__cleanup_arg)
+# define __whence (git_ctx->builtin_commit.__whence)
+# define use_editor (git_ctx->builtin_commit.__use_editor)
+# define include_status (git_ctx->builtin_commit.__include_status)
+# define have_option_m (git_ctx->builtin_commit.__have_option_m)
+# define message (git_ctx->builtin_commit.__message)
+# define __status_format (git_ctx->builtin_commit.__status_format)
+#else
 static const char *use_message_buffer;
 static struct lock_file index_lock; /* real index */
 static struct lock_file false_lock; /* used only for partial commits */
@@ -108,12 +162,12 @@ static const char *author_message, *author_message_buffer;
 static char *edit_message, *use_message;
 static char *fixup_message, *fixup_commit, *squash_message;
 static const char *fixup_prefix;
-static int all, also, interactive, patch_interactive, only, amend, signoff;
+static int all, also, interactive, patch_interactive, only, __amend, signoff;
 static int edit_flag = -1; /* unspecified */
-static int quiet, verbose, no_verify, allow_empty, dry_run, renew_authorship;
+static int quiet, __verbose, no_verify, allow_empty, dry_run, renew_authorship;
 static int config_commit_verbose = -1; /* unspecified */
 static int no_post_rewrite, allow_empty_message, pathspec_file_nul;
-static char *untracked_files_arg, *force_date, *ignore_submodule_arg, *ignored_arg;
+static char *untracked_files_arg, *force_date, *__ignore_submodule_arg, *ignored_arg;
 static char *sign_commit, *pathspec_from_file;
 static struct strvec trailer_args = STRVEC_INIT;
 
@@ -127,12 +181,13 @@ static struct strvec trailer_args = STRVEC_INIT;
 static enum commit_msg_cleanup_mode cleanup_mode;
 static const char *cleanup_arg;
 
-static enum commit_whence whence;
+static enum commit_whence __whence;
 static int use_editor = 1, include_status = 1;
 static int have_option_m;
 static struct strbuf message = STRBUF_INIT;
 
-static enum wt_status_format status_format = STATUS_FORMAT_UNSPECIFIED;
+static enum wt_status_format __status_format = STATUS_FORMAT_UNSPECIFIED;
+#endif
 
 static int opt_pass_trailer(const struct option *opt, const char *arg, int unset)
 {
@@ -191,11 +246,11 @@ static int opt_parse_rename_score(const struct option *opt, const char *arg, int
 static void determine_whence(struct wt_status *s)
 {
 	if (file_exists(git_path_merge_head(the_repository)))
-		whence = FROM_MERGE;
-	else if (!sequencer_determine_whence(the_repository, &whence))
-		whence = FROM_COMMIT;
+		__whence = FROM_MERGE;
+	else if (!sequencer_determine_whence(the_repository, &__whence))
+		__whence = FROM_COMMIT;
 	if (s)
-		s->whence = whence;
+		s->whence = __whence;
 }
 
 static void status_init_config(struct wt_status *s, config_fn_t fn)
@@ -371,7 +426,7 @@ static const char *prepare_index(const char **argv, const char *prefix,
 	}
 
 	if (!pathspec.nr && (also || (only && !allow_empty &&
-	    (!amend || (fixup_message && strcmp(fixup_prefix, "amend"))))))
+	    (!__amend || (fixup_message && strcmp(fixup_prefix, "amend"))))))
 		die(_("No paths with --include/--only does not make sense."));
 
 	if (read_cache_preload(&pathspec) < 0)
@@ -485,12 +540,12 @@ static const char *prepare_index(const char **argv, const char *prefix,
 	 */
 	commit_style = COMMIT_PARTIAL;
 
-	if (whence != FROM_COMMIT) {
-		if (whence == FROM_MERGE)
+	if (__whence != FROM_COMMIT) {
+		if (__whence == FROM_MERGE)
 			die(_("cannot do a partial commit during a merge."));
-		else if (is_from_cherry_pick(whence))
+		else if (is_from_cherry_pick(__whence))
 			die(_("cannot do a partial commit during a cherry-pick."));
-		else if (is_from_rebase(whence))
+		else if (is_from_rebase(__whence))
 			die(_("cannot do a partial commit during a rebase."));
 	}
 
@@ -537,19 +592,19 @@ static int run_status(FILE *fp, const char *index_file, const char *prefix, int
 	if (s->relative_paths)
 		s->prefix = prefix;
 
-	if (amend) {
+	if (__amend) {
 		s->amend = 1;
 		s->reference = "HEAD^1";
 	}
-	s->verbose = verbose;
+	s->verbose = __verbose;
 	s->index_file = index_file;
 	s->fp = fp;
 	s->nowarn = nowarn;
 	s->is_initial = get_oid(s->reference, &oid) ? 1 : 0;
 	if (!s->is_initial)
 		oidcpy(&s->oid_commit, &oid);
-	s->status_format = status_format;
-	s->ignore_submodule_arg = ignore_submodule_arg;
+	s->status_format = __status_format;
+	s->ignore_submodule_arg = __ignore_submodule_arg;
 
 	wt_status_collect(s);
 	wt_status_print(s);
@@ -840,9 +895,9 @@ static int prepare_to_commit(const char *index_file, const char *prefix,
 	 * The remaining cases don't modify the template message, but
 	 * just set the argument(s) to the prepare-commit-msg hook.
 	 */
-	else if (whence == FROM_MERGE)
+	else if (__whence == FROM_MERGE)
 		hook_arg1 = "merge";
-	else if (is_from_cherry_pick(whence) || whence == FROM_REBASE_PICK) {
+	else if (is_from_cherry_pick(__whence) || __whence == FROM_REBASE_PICK) {
 		hook_arg1 = "commit";
 		hook_arg2 = "CHERRY_PICK_HEAD";
 	}
@@ -906,13 +961,13 @@ static int prepare_to_commit(const char *index_file, const char *prefix,
 			  "with '%c' will be kept; you may remove them"
 			  " yourself if you want to.\n"
 			  "An empty message aborts the commit.\n");
-		if (whence != FROM_COMMIT) {
+		if (__whence != FROM_COMMIT) {
 			if (cleanup_mode == COMMIT_MSG_CLEANUP_SCISSORS &&
 				!merge_contains_scissors)
 				wt_status_add_cut_line(s->fp);
 			status_printf_ln(
 				s, GIT_COLOR_NORMAL,
-				whence == FROM_MERGE ?
+				__whence == FROM_MERGE ?
 					      _("\n"
 					  "It looks like you may be committing a merge.\n"
 					  "If this is not correct, please run\n"
@@ -929,7 +984,7 @@ static int prepare_to_commit(const char *index_file, const char *prefix,
 		if (cleanup_mode == COMMIT_MSG_CLEANUP_ALL)
 			status_printf(s, GIT_COLOR_NORMAL, hint_cleanup_all, comment_line_char);
 		else if (cleanup_mode == COMMIT_MSG_CLEANUP_SCISSORS) {
-			if (whence == FROM_COMMIT && !merge_contains_scissors)
+			if (__whence == FROM_COMMIT && !merge_contains_scissors)
 				wt_status_add_cut_line(s->fp);
 		} else /* COMMIT_MSG_CLEANUP_SPACE, that is. */
 			status_printf(s, GIT_COLOR_NORMAL, hint_cleanup_space, comment_line_char);
@@ -980,7 +1035,7 @@ static int prepare_to_commit(const char *index_file, const char *prefix,
 		if (!active_nr && read_cache() < 0)
 			die(_("Cannot read index"));
 
-		if (amend)
+		if (__amend)
 			parent = "HEAD^1";
 
 		if (get_oid(parent, &oid)) {
@@ -1004,8 +1059,8 @@ static int prepare_to_commit(const char *index_file, const char *prefix,
 			 */
 			struct diff_flags flags = DIFF_FLAGS_INIT;
 			flags.override_submodule_config = 1;
-			if (ignore_submodule_arg &&
-			    !strcmp(ignore_submodule_arg, "all"))
+			if (__ignore_submodule_arg &&
+			    !strcmp(__ignore_submodule_arg, "all"))
 				flags.ignore_submodules = 1;
 			committable = index_differs_from(the_repository,
 							 parent, &flags, 1);
@@ -1032,19 +1087,19 @@ static int prepare_to_commit(const char *index_file, const char *prefix,
 	 * explicit --allow-empty. In the cherry-pick case, it may be
 	 * empty due to conflict resolution, which the user should okay.
 	 */
-	if (!committable && whence != FROM_MERGE && !allow_empty &&
-	    !(amend && is_a_merge(current_head))) {
+	if (!committable && __whence != FROM_MERGE && !allow_empty &&
+	    !(__amend && is_a_merge(current_head))) {
 		s->hints = advice_enabled(ADVICE_STATUS_HINTS);
 		s->display_comment_prefix = old_display_comment_prefix;
 		run_status(stdout, index_file, prefix, 0, s);
-		if (amend)
+		if (__amend)
 			fputs(_(empty_amend_advice), stderr);
-		else if (is_from_cherry_pick(whence) ||
-			 whence == FROM_REBASE_PICK) {
+		else if (is_from_cherry_pick(__whence) ||
+			 __whence == FROM_REBASE_PICK) {
 			fputs(_(empty_cherry_pick_advice), stderr);
-			if (whence == FROM_CHERRY_PICK_SINGLE)
+			if (__whence == FROM_CHERRY_PICK_SINGLE)
 				fputs(_(empty_cherry_pick_advice_single), stderr);
-			else if (whence == FROM_CHERRY_PICK_MULTI)
+			else if (__whence == FROM_CHERRY_PICK_MULTI)
 				fputs(_(empty_cherry_pick_advice_multi), stderr);
 			else
 				fputs(_(empty_rebase_pick_advice), stderr);
@@ -1168,6 +1223,9 @@ static const char *read_commit_message(const char *name)
 	return logmsg_reencode(commit, NULL, out_enc);
 }
 
+#ifdef __VSF__
+# define status_deferred_config (git_ctx->builtin_commit.__status_deferred_config)
+#else
 /*
  * Enumerate what needs to be propagated when --porcelain
  * is not in effect here.
@@ -1181,25 +1239,26 @@ static struct status_deferred_config {
 	-1, /* unspecified */
 	AHEAD_BEHIND_UNSPECIFIED,
 };
+#endif
 
 static void finalize_deferred_config(struct wt_status *s)
 {
-	int use_deferred_config = (status_format != STATUS_FORMAT_PORCELAIN &&
-				   status_format != STATUS_FORMAT_PORCELAIN_V2 &&
+	int use_deferred_config = (__status_format != STATUS_FORMAT_PORCELAIN &&
+				   __status_format != STATUS_FORMAT_PORCELAIN_V2 &&
 				   !s->null_termination);
 
 	if (s->null_termination) {
-		if (status_format == STATUS_FORMAT_NONE ||
-		    status_format == STATUS_FORMAT_UNSPECIFIED)
-			status_format = STATUS_FORMAT_PORCELAIN;
-		else if (status_format == STATUS_FORMAT_LONG)
+		if (__status_format == STATUS_FORMAT_NONE ||
+		    __status_format == STATUS_FORMAT_UNSPECIFIED)
+			__status_format = STATUS_FORMAT_PORCELAIN;
+		else if (__status_format == STATUS_FORMAT_LONG)
 			die(_("options '%s' and '%s' cannot be used together"), "--long", "-z");
 	}
 
-	if (use_deferred_config && status_format == STATUS_FORMAT_UNSPECIFIED)
-		status_format = status_deferred_config.status_format;
-	if (status_format == STATUS_FORMAT_UNSPECIFIED)
-		status_format = STATUS_FORMAT_NONE;
+	if (use_deferred_config && __status_format == STATUS_FORMAT_UNSPECIFIED)
+		__status_format = status_deferred_config.status_format;
+	if (__status_format == STATUS_FORMAT_UNSPECIFIED)
+		__status_format = STATUS_FORMAT_NONE;
 
 	if (use_deferred_config && s->show_branch < 0)
 		s->show_branch = status_deferred_config.show_branch;
@@ -1222,10 +1281,10 @@ static void finalize_deferred_config(struct wt_status *s)
 }
 
 static void check_fixup_reword_options(int argc, const char *argv[]) {
-	if (whence != FROM_COMMIT) {
-		if (whence == FROM_MERGE)
+	if (__whence != FROM_COMMIT) {
+		if (__whence == FROM_MERGE)
 			die(_("You are in the middle of a merge -- cannot reword."));
-		else if (is_from_cherry_pick(whence))
+		else if (is_from_cherry_pick(__whence))
 			die(_("You are in the middle of a cherry-pick -- cannot reword."));
 	}
 	if (argc)
@@ -1257,14 +1316,14 @@ static int parse_and_validate_options(int argc, const char *argv[],
 		use_editor = 0;
 
 	/* Sanity check options */
-	if (amend && !current_head)
+	if (__amend && !current_head)
 		die(_("You have nothing to amend."));
-	if (amend && whence != FROM_COMMIT) {
-		if (whence == FROM_MERGE)
+	if (__amend && __whence != FROM_COMMIT) {
+		if (__whence == FROM_MERGE)
 			die(_("You are in the middle of a merge -- cannot amend."));
-		else if (is_from_cherry_pick(whence))
+		else if (is_from_cherry_pick(__whence))
 			die(_("You are in the middle of a cherry-pick -- cannot amend."));
-		else if (whence == FROM_REBASE_PICK)
+		else if (__whence == FROM_REBASE_PICK)
 			die(_("You are in the middle of a rebase -- cannot amend."));
 	}
 	if (fixup_message && squash_message)
@@ -1285,10 +1344,10 @@ static int parse_and_validate_options(int argc, const char *argv[],
 		template_file = NULL;
 	if (edit_message)
 		use_message = edit_message;
-	if (amend && !use_message && !fixup_message)
+	if (__amend && !use_message && !fixup_message)
 		use_message = "HEAD";
-	if (!use_message && !is_from_cherry_pick(whence) &&
-	    !is_from_rebase(whence) && renew_authorship)
+	if (!use_message && !is_from_cherry_pick(__whence) &&
+	    !is_from_rebase(__whence) && renew_authorship)
 		die(_("--reset-author can be used only with -C, -c or --amend."));
 	if (use_message) {
 		use_message_buffer = read_commit_message(use_message);
@@ -1297,7 +1356,7 @@ static int parse_and_validate_options(int argc, const char *argv[],
 			author_message_buffer = use_message_buffer;
 		}
 	}
-	if ((is_from_cherry_pick(whence) || whence == FROM_REBASE_PICK) &&
+	if ((is_from_cherry_pick(__whence) || __whence == FROM_REBASE_PICK) &&
 	    !renew_authorship) {
 		author_message = "CHERRY_PICK_HEAD";
 		author_message_buffer = read_commit_message(author_message);
@@ -1355,7 +1414,7 @@ static int parse_and_validate_options(int argc, const char *argv[],
 		die(_("paths '%s ...' with -a does not make sense"),
 		    argv[0]);
 
-	if (status_format != STATUS_FORMAT_NONE)
+	if (__status_format != STATUS_FORMAT_NONE)
 		dry_run = 1;
 
 	return argc;
@@ -1474,15 +1533,21 @@ static int git_status_config(const char *k, const char *v, void *cb)
 
 int cmd_status(int argc, const char **argv, const char *prefix)
 {
+#ifdef __VSF__
+# define no_renames (git_ctx->builtin_commit.cmd_status.__no_renames)
+# define rename_score_arg (git_ctx->builtin_commit.cmd_status.__rename_score_arg)
+# define s (git_ctx->builtin_commit.cmd_status.__s)
+#else
 	static int no_renames = -1;
 	static const char *rename_score_arg = (const char *)-1;
 	static struct wt_status s;
+#endif
 	unsigned int progress_flag = 0;
 	int fd;
 	struct object_id oid;
-	static struct option builtin_status_options[] = {
-		OPT__VERBOSE(&verbose, N_("be verbose")),
-		OPT_SET_INT('s', "short", &status_format,
+	struct option builtin_status_options[] = {
+		OPT__VERBOSE(&__verbose, N_("be verbose")),
+		OPT_SET_INT('s', "short", &__status_format,
 			    N_("show status concisely"), STATUS_FORMAT_SHORT),
 		OPT_BOOL('b', "branch", &s.show_branch,
 			 N_("show branch information")),
@@ -1490,10 +1555,10 @@ int cmd_status(int argc, const char **argv, const char *prefix)
 			 N_("show stash information")),
 		OPT_BOOL(0, "ahead-behind", &s.ahead_behind_flags,
 			 N_("compute full ahead/behind values")),
-		OPT_CALLBACK_F(0, "porcelain", &status_format,
+		OPT_CALLBACK_F(0, "porcelain", &__status_format,
 		  N_("version"), N_("machine-readable output"),
 		  PARSE_OPT_OPTARG, opt_parse_porcelain),
-		OPT_SET_INT(0, "long", &status_format,
+		OPT_SET_INT(0, "long", &__status_format,
 			    N_("show status in long format (default)"),
 			    STATUS_FORMAT_LONG),
 		OPT_BOOL('z', "null", &s.null_termination,
@@ -1506,7 +1571,7 @@ int cmd_status(int argc, const char **argv, const char *prefix)
 		  N_("mode"),
 		  N_("show ignored files, optional modes: traditional, matching, no. (Default: traditional)"),
 		  PARSE_OPT_OPTARG, NULL, (intptr_t)"traditional" },
-		{ OPTION_STRING, 0, "ignore-submodules", &ignore_submodule_arg, N_("when"),
+		{ OPTION_STRING, 0, "ignore-submodules", &__ignore_submodule_arg, N_("when"),
 		  N_("ignore changes to submodules, optional when: all, dirty, untracked. (Default: all)"),
 		  PARSE_OPT_OPTARG, NULL, (intptr_t)"all" },
 		OPT_COLUMN(0, "column", &s.colopts, N_("list untracked files in columns")),
@@ -1541,8 +1606,8 @@ int cmd_status(int argc, const char **argv, const char *prefix)
 		       PATHSPEC_PREFER_FULL,
 		       prefix, argv);
 
-	if (status_format != STATUS_FORMAT_PORCELAIN &&
-	    status_format != STATUS_FORMAT_PORCELAIN_V2)
+	if (__status_format != STATUS_FORMAT_PORCELAIN &&
+	    __status_format != STATUS_FORMAT_PORCELAIN_V2)
 		progress_flag = REFRESH_PROGRESS;
 	repo_read_index(the_repository);
 	refresh_index(&the_index,
@@ -1558,9 +1623,9 @@ int cmd_status(int argc, const char **argv, const char *prefix)
 	if (!s.is_initial)
 		oidcpy(&s.oid_commit, &oid);
 
-	s.ignore_submodule_arg = ignore_submodule_arg;
-	s.status_format = status_format;
-	s.verbose = verbose;
+	s.ignore_submodule_arg = __ignore_submodule_arg;
+	s.status_format = __status_format;
+	s.verbose = __verbose;
 	if (no_renames != -1)
 		s.detect_rename = !no_renames;
 	if ((intptr_t)rename_score_arg != -1) {
@@ -1582,6 +1647,11 @@ int cmd_status(int argc, const char **argv, const char *prefix)
 	wt_status_collect_free_buffers(&s);
 
 	return 0;
+#ifdef __VSF__
+# undef no_renames
+# undef rename_score_arg
+# undef s
+#endif
 }
 
 static int git_commit_config(const char *k, const char *v, void *cb)
@@ -1615,10 +1685,14 @@ static int git_commit_config(const char *k, const char *v, void *cb)
 
 int cmd_commit(int argc, const char **argv, const char *prefix)
 {
+#ifdef __VSF__
+# define s (git_ctx->builtin_commit.cmd_commit.__s)
+#else
 	static struct wt_status s;
-	static struct option builtin_commit_options[] = {
+#endif
+	struct option builtin_commit_options[] = {
 		OPT__QUIET(&quiet, N_("suppress summary after successful commit")),
-		OPT__VERBOSE(&verbose, N_("show diff in commit message template")),
+		OPT__VERBOSE(&__verbose, N_("show diff in commit message template")),
 
 		OPT_GROUP(N_("Commit message options")),
 		OPT_FILENAME('F', "file", &logfile, N_("read message from file")),
@@ -1652,19 +1726,19 @@ int cmd_commit(int argc, const char **argv, const char *prefix)
 		OPT_BOOL('o', "only", &only, N_("commit only specified files")),
 		OPT_BOOL('n', "no-verify", &no_verify, N_("bypass pre-commit and commit-msg hooks")),
 		OPT_BOOL(0, "dry-run", &dry_run, N_("show what would be committed")),
-		OPT_SET_INT(0, "short", &status_format, N_("show status concisely"),
+		OPT_SET_INT(0, "short", &__status_format, N_("show status concisely"),
 			    STATUS_FORMAT_SHORT),
 		OPT_BOOL(0, "branch", &s.show_branch, N_("show branch information")),
 		OPT_BOOL(0, "ahead-behind", &s.ahead_behind_flags,
 			 N_("compute full ahead/behind values")),
-		OPT_SET_INT(0, "porcelain", &status_format,
+		OPT_SET_INT(0, "porcelain", &__status_format,
 			    N_("machine-readable output"), STATUS_FORMAT_PORCELAIN),
-		OPT_SET_INT(0, "long", &status_format,
+		OPT_SET_INT(0, "long", &__status_format,
 			    N_("show status in long format (default)"),
 			    STATUS_FORMAT_LONG),
 		OPT_BOOL('z', "null", &s.null_termination,
 			 N_("terminate entries with NUL")),
-		OPT_BOOL(0, "amend", &amend, N_("amend previous commit")),
+		OPT_BOOL(0, "amend", &__amend, N_("amend previous commit")),
 		OPT_BOOL(0, "no-post-rewrite", &no_post_rewrite, N_("bypass post-rewrite hook")),
 		{ OPTION_STRING, 'u', "untracked-files", &untracked_files_arg, N_("mode"), N_("show untracked files, optional modes: all, normal, no. (Default: all)"), PARSE_OPT_OPTARG, NULL, (intptr_t)"all" },
 		OPT_PATHSPEC_FROM_FILE(&pathspec_from_file),
@@ -1697,7 +1771,7 @@ int cmd_commit(int argc, const char **argv, const char *prefix)
 
 	status_init_config(&s, git_commit_config);
 	s.commit_template = 1;
-	status_format = STATUS_FORMAT_NONE; /* Ignore status.short */
+	__status_format = STATUS_FORMAT_NONE; /* Ignore status.short */
 	s.colopts = 0;
 
 	if (get_oid("HEAD", &oid))
@@ -1707,12 +1781,12 @@ int cmd_commit(int argc, const char **argv, const char *prefix)
 		if (parse_commit(current_head))
 			die(_("could not parse HEAD commit"));
 	}
-	verbose = -1; /* unspecified */
+	__verbose = -1; /* unspecified */
 	argc = parse_and_validate_options(argc, argv, builtin_commit_options,
 					  builtin_commit_usage,
 					  prefix, current_head, &s);
-	if (verbose == -1)
-		verbose = (config_commit_verbose < 0) ? 0 : config_commit_verbose;
+	if (__verbose == -1)
+		__verbose = (config_commit_verbose < 0) ? 0 : config_commit_verbose;
 
 	if (dry_run)
 		return dry_run_commit(argv, prefix, current_head, &s);
@@ -1731,11 +1805,11 @@ int cmd_commit(int argc, const char **argv, const char *prefix)
 	if (!current_head) {
 		if (!reflog_msg)
 			reflog_msg = "commit (initial)";
-	} else if (amend) {
+	} else if (__amend) {
 		if (!reflog_msg)
 			reflog_msg = "commit (amend)";
 		parents = copy_commit_list(current_head->parents);
-	} else if (whence == FROM_MERGE) {
+	} else if (__whence == FROM_MERGE) {
 		struct strbuf m = STRBUF_INIT;
 		FILE *fp;
 		int allow_fast_forward = 1;
@@ -1765,9 +1839,9 @@ int cmd_commit(int argc, const char **argv, const char *prefix)
 			reduce_heads_replace(&parents);
 	} else {
 		if (!reflog_msg)
-			reflog_msg = is_from_cherry_pick(whence)
+			reflog_msg = is_from_cherry_pick(__whence)
 					? "commit (cherry-pick)"
-					: is_from_rebase(whence)
+					: is_from_rebase(__whence)
 					? "commit (rebase)"
 					: "commit";
 		commit_list_insert(current_head, &parents);
@@ -1781,7 +1855,7 @@ int cmd_commit(int argc, const char **argv, const char *prefix)
 		die(_("could not read commit message: %s"), strerror(saved_errno));
 	}
 
-	cleanup_message(&sb, cleanup_mode, verbose);
+	cleanup_message(&sb, cleanup_mode, __verbose);
 
 	if (message_is_empty(&sb, cleanup_mode) && !allow_empty_message) {
 		rollback_index_files();
@@ -1807,7 +1881,7 @@ int cmd_commit(int argc, const char **argv, const char *prefix)
 		strbuf_release(&body);
 	}
 
-	if (amend) {
+	if (__amend) {
 		const char *exclude_gpgsig[3] = { "gpgsig", "gpgsig-sha256", NULL };
 		extra = read_commit_extra_headers(current_head, exclude_gpgsig);
 	} else {
@@ -1846,7 +1920,7 @@ int cmd_commit(int argc, const char **argv, const char *prefix)
 	repo_rerere(the_repository, 0);
 	run_auto_maintenance(quiet);
 	run_commit_hook(use_editor, get_index_file(), "post-commit", NULL);
-	if (amend && !no_post_rewrite) {
+	if (__amend && !no_post_rewrite) {
 		commit_post_rewrite(the_repository, current_head, &oid);
 	}
 	if (!quiet) {
diff --git a/builtin/config.c b/builtin/config.c
index 542d8d02b2..1add259cf0 100644
--- a/builtin/config.c
+++ b/builtin/config.c
@@ -7,12 +7,44 @@
 #include "quote.h"
 #include "worktree.h"
 
+#ifdef __VSF__
+# include "git_port_vsf.h"
+#endif
+
 static const char *const builtin_config_usage[] = {
 	N_("git config [<options>]"),
 	NULL
 };
 
-static char *key;
+#ifdef __VSF__
+# define __key (git_ctx->builtin_config.__key)
+# define key_regexp (git_ctx->builtin_config.__key_regexp)
+# define value_pattern (git_ctx->builtin_config.__value_pattern)
+# define regexp (git_ctx->builtin_config.__regexp)
+# define show_keys (git_ctx->builtin_config.__show_keys)
+# define omit_values (git_ctx->builtin_config.__omit_values)
+# define use_key_regexp (git_ctx->builtin_config.__use_key_regexp)
+# define do_all (git_ctx->builtin_config.__do_all)
+# define do_not_match (git_ctx->builtin_config.__do_not_match)
+# define delim (git_ctx->builtin_config.__delim)
+# define key_delim (git_ctx->builtin_config.__key_delim)
+# define __term (git_ctx->builtin_config.__term)
+# define use_global_config (git_ctx->builtin_config.__use_global_config)
+# define use_system_config (git_ctx->builtin_config.__use_system_config)
+# define use_local_config (git_ctx->builtin_config.__use_local_config)
+# define use_worktree_config (git_ctx->builtin_config.__use_worktree_config)
+# define given_config_source (git_ctx->builtin_config.__given_config_source)
+# define actions (git_ctx->builtin_config.__actions)
+# define type (git_ctx->builtin_config.__type)
+# define default_value (git_ctx->builtin_config.__default_value)
+# define end_nul (git_ctx->builtin_config.__end_nul)
+# define respect_includes_opt (git_ctx->builtin_config.__respect_includes_opt)
+# define config_options (git_ctx->builtin_config.__config_options)
+# define show_origin (git_ctx->builtin_config.__show_origin)
+# define show_scope (git_ctx->builtin_config.__show_scope)
+# define fixed_value (git_ctx->builtin_config.__fixed_value)
+#else
+static char *__key;
 static regex_t *key_regexp;
 static const char *value_pattern;
 static regex_t *regexp;
@@ -23,7 +55,7 @@ static int do_all;
 static int do_not_match;
 static char delim = '=';
 static char key_delim = ' ';
-static char term = '\n';
+static char __term = '\n';
 
 static int use_global_config, use_system_config, use_local_config;
 static int use_worktree_config;
@@ -36,6 +68,7 @@ static struct config_options config_options;
 static int show_origin;
 static int show_scope;
 static int fixed_value;
+#endif
 
 #define ACTION_GET (1<<0)
 #define ACTION_GET_ALL (1<<1)
@@ -75,7 +108,7 @@ static int fixed_value;
 
 static NORETURN void usage_builtin_config(void);
 
-static int option_parse_type(const struct option *opt, const char *arg,
+int option_parse_type(const struct option *opt, const char *arg,
 			     int unset)
 {
 	int new_type, *to_type;
@@ -126,6 +159,9 @@ static int option_parse_type(const struct option *opt, const char *arg,
 	return 0;
 }
 
+#ifdef __VSF__
+# define builtin_config_options (git_ctx->builtin_config.__builtin_config_options)
+#else
 static struct option builtin_config_options[] = {
 	OPT_GROUP(N_("Config file location")),
 	OPT_BOOL(0, "global", &use_global_config, N_("use global config file")),
@@ -167,6 +203,7 @@ static struct option builtin_config_options[] = {
 	OPT_STRING(0, "default", &default_value, N_("value"), N_("with --get, use default value when missing entry")),
 	OPT_END(),
 };
+#endif
 
 static NORETURN void usage_builtin_config(void)
 {
@@ -220,9 +257,9 @@ static int show_all_config(const char *key_, const char *value_, void *cb)
 		strbuf_release(&buf);
 	}
 	if (!omit_values && value_)
-		printf("%s%c%s%c", key_, delim, value_, term);
+		printf("%s%c%s%c", key_, delim, value_, __term);
 	else
-		printf("%s%c", key_, term);
+		printf("%s%c", key_, __term);
 	return 0;
 }
 
@@ -287,7 +324,7 @@ static int format_config(struct strbuf *buf, const char *key_, const char *value
 				strbuf_setlen(buf, buf->len - 1);
 		}
 	}
-	strbuf_addch(buf, term);
+	strbuf_addch(buf, __term);
 	return 0;
 }
 
@@ -295,7 +332,7 @@ static int collect_config(const char *key_, const char *value_, void *cb)
 {
 	struct strbuf_list *values = cb;
 
-	if (!use_key_regexp && strcmp(key_, key))
+	if (!use_key_regexp && strcmp(key_, __key))
 		return 0;
 	if (use_key_regexp && regexec(key_regexp, key_, 0, NULL, 0))
 		return 0;
@@ -326,23 +363,23 @@ static int get_value(const char *key_, const char *regex_, unsigned flags)
 		 * Perhaps we should deprecate this altogether someday.
 		 */
 
-		key = xstrdup(key_);
-		for (tl = key + strlen(key) - 1;
-		     tl >= key && *tl != '.';
+		__key = xstrdup(key_);
+		for (tl = __key + strlen(__key) - 1;
+		     tl >= __key && *tl != '.';
 		     tl--)
 			*tl = tolower(*tl);
-		for (tl = key; *tl && *tl != '.'; tl++)
+		for (tl = __key; *tl && *tl != '.'; tl++)
 			*tl = tolower(*tl);
 
 		key_regexp = (regex_t*)xmalloc(sizeof(regex_t));
-		if (regcomp(key_regexp, key, REG_EXTENDED)) {
+		if (regcomp(key_regexp, __key, REG_EXTENDED)) {
 			error(_("invalid key pattern: %s"), key_);
 			FREE_AND_NULL(key_regexp);
 			ret = CONFIG_INVALID_PATTERN;
 			goto free_strings;
 		}
 	} else {
-		if (git_config_parse_key(key_, &key, NULL)) {
+		if (git_config_parse_key(key_, &__key, NULL)) {
 			ret = CONFIG_INVALID_KEY;
 			goto free_strings;
 		}
@@ -389,7 +426,7 @@ static int get_value(const char *key_, const char *regex_, unsigned flags)
 	free(values.items);
 
 free_strings:
-	free(key);
+	free(__key);
 	if (key_regexp) {
 		regfree(key_regexp);
 		free(key_regexp);
@@ -453,10 +490,17 @@ static char *normalize_value(const char *key, const char *value)
 	BUG("cannot normalize type %d", type);
 }
 
+#ifdef __VSF__
+# define get_color_found (git_ctx->builtin_config.__get_color_found)
+# define get_color_slot (git_ctx->builtin_config.__get_color_slot)
+# define get_colorbool_slot (git_ctx->builtin_config.__get_colorbool_slot)
+# define parsed_color (git_ctx->builtin_config.__parsed_color)
+#else
 static int get_color_found;
 static const char *get_color_slot;
 static const char *get_colorbool_slot;
 static char parsed_color[COLOR_MAXLEN];
+#endif
 
 static int git_get_color_config(const char *var, const char *value, void *cb)
 {
@@ -486,9 +530,15 @@ static void get_color(const char *var, const char *def_color)
 	fputs(parsed_color, stdout);
 }
 
+#ifdef __VSF__
+# define get_colorbool_found (git_ctx->builtin_config.__get_colorbool_found)
+# define get_diff_color_found (git_ctx->builtin_config.__get_diff_color_found)
+# define get_color_ui_found (git_ctx->builtin_config.__get_color_ui_found)
+#else
 static int get_colorbool_found;
 static int get_diff_color_found;
 static int get_color_ui_found;
+#endif
 static int git_get_colorbool_config(const char *var, const char *value,
 		void *cb)
 {
@@ -734,7 +784,7 @@ int cmd_config(int argc, const char **argv, const char *prefix)
 	}
 
 	if (end_nul) {
-		term = '\0';
+		__term = '\0';
 		delim = '\n';
 		key_delim = '\n';
 	}
diff --git a/builtin/count-objects.c b/builtin/count-objects.c
index 3fae474f6f..c36fc4e0df 100644
--- a/builtin/count-objects.c
+++ b/builtin/count-objects.c
@@ -14,11 +14,25 @@
 #include "packfile.h"
 #include "object-store.h"
 
+#ifdef __VSF__
+# include "git_port_vsf.h"
+#endif
+
+#ifdef __VSF__
+# define garbage (git_ctx->builtin_count_objects.__garbage)
+# define size_garbage (git_ctx->builtin_count_objects.__size_garbage)
+# define verbose (git_ctx->builtin_count_objects.__verbose)
+# define loose (git_ctx->builtin_count_objects.__loose)
+# define packed (git_ctx->builtin_count_objects.__packed)
+# define packed_loose (git_ctx->builtin_count_objects.__packed_loose)
+# define loose_size (git_ctx->builtin_count_objects.__loose_size)
+#else
 static unsigned long garbage;
 static off_t size_garbage;
 static int verbose;
 static unsigned long loose, packed, packed_loose;
 static off_t loose_size;
+#endif
 
 static const char *bits_to_msg(unsigned seen_bits)
 {
diff --git a/builtin/credential-cache--daemon.c b/builtin/credential-cache--daemon.c
index 4c6c89ab0d..19ff41f543 100644
--- a/builtin/credential-cache--daemon.c
+++ b/builtin/credential-cache--daemon.c
@@ -8,6 +8,15 @@
 #include "credential.h"
 #include "unix-socket.h"
 
+#ifdef __VSF__
+# include "git_port_vsf.h"
+#endif
+
+#ifdef __VSF__
+# define entries (git_ctx->builtin_credential_cahce_daemon.__entries)
+# define entries_nr (git_ctx->builtin_credential_cahce_daemon.__entries_nr)
+# define entries_alloc (git_ctx->builtin_credential_cahce_daemon.__entries_alloc)
+#else
 struct credential_cache_entry {
 	struct credential item;
 	timestamp_t expiration;
@@ -15,6 +24,7 @@ struct credential_cache_entry {
 static struct credential_cache_entry *entries;
 static int entries_nr;
 static int entries_alloc;
+#endif
 
 static void cache_credential(struct credential *c, int timeout)
 {
@@ -51,7 +61,11 @@ static void remove_credential(const struct credential *c)
 
 static timestamp_t check_expirations(void)
 {
+#ifdef __VSF__
+# define wait_for_entry_until (git_ctx->builtin_credential_cahce_daemon.check_expirations.__wait_for_entry_until)
+#else
 	static timestamp_t wait_for_entry_until;
+#endif
 	int i = 0;
 	timestamp_t now = time(NULL);
 	timestamp_t next = TIME_MAX;
@@ -91,12 +105,19 @@ static timestamp_t check_expirations(void)
 	}
 
 	return next - now;
+#ifdef __VSF__
+# undef wait_for_entry_until
+#endif
 }
 
 static int read_request(FILE *fh, struct credential *c,
 			struct strbuf *action, int *timeout)
 {
+#ifdef __VSF__
+# define item (git_ctx->builtin_credential_cahce_daemon.read_request.__item)
+#else
 	static struct strbuf item = STRBUF_INIT;
+#endif
 	const char *p;
 
 	strbuf_getline_lf(&item, fh);
@@ -112,6 +133,9 @@ static int read_request(FILE *fh, struct credential *c,
 	if (credential_read(c, fh) < 0)
 		return -1;
 	return 0;
+#ifdef __VSF__
+# undef item
+#endif
 }
 
 static void serve_one_client(FILE *in, FILE *out)
diff --git a/builtin/credential-store.c b/builtin/credential-store.c
index 62a4f3c265..cfa13545ff 100644
--- a/builtin/credential-store.c
+++ b/builtin/credential-store.c
@@ -5,7 +5,15 @@
 #include "string-list.h"
 #include "parse-options.h"
 
+#ifdef __VSF__
+# include "git_port_vsf.h"
+#endif
+
+#ifdef __VSF__
+# define credential_lock (git_ctx->builtin_credential_store.__credential_lock)
+#else
 static struct lock_file credential_lock;
+#endif
 
 static int parse_credential_file(const char *fn,
 				  struct credential *c,
diff --git a/builtin/describe.c b/builtin/describe.c
index 42159cd26b..f481a6c60f 100644
--- a/builtin/describe.c
+++ b/builtin/describe.c
@@ -18,9 +18,15 @@
 #include "list-objects.h"
 #include "commit-slab.h"
 
+#ifdef __VSF__
+# include "git_port_vsf.h"
+#endif
+
 #define MAX_TAGS	(FLAG_BITS - 1)
 
+#ifndef __VSF__
 define_commit_slab(commit_names, struct commit_name *);
+#endif
 
 static const char * const describe_usage[] = {
 	N_("git describe [<options>] [<commit-ish>...]"),
@@ -28,6 +34,24 @@ static const char * const describe_usage[] = {
 	NULL
 };
 
+#ifdef __VSF__
+# define debug (git_ctx->builtin_describe.__debug)
+# define all (git_ctx->builtin_describe.__all)
+# define tags (git_ctx->builtin_describe.__tags)
+# define longformat (git_ctx->builtin_describe.__longformat)
+# define first_parent (git_ctx->builtin_describe.__first_parent)
+# define abbrev (git_ctx->builtin_describe.__abbrev)
+# define max_candidates (git_ctx->builtin_describe.__max_candidates)
+# define names (git_ctx->builtin_describe.__names)
+# define have_util (git_ctx->builtin_describe.__have_util)
+# define patterns (git_ctx->builtin_describe.__patterns)
+# define exclude_patterns (git_ctx->builtin_describe.__exclude_patterns)
+# define always (git_ctx->builtin_describe.__always)
+# define suffix (git_ctx->builtin_describe.__suffix)
+# define dirty (git_ctx->builtin_describe.__dirty)
+# define broken (git_ctx->builtin_describe.__broken)
+# define __commit_names (git_ctx->builtin_describe.__commit_names)
+#else
 static int debug;	/* Display lots of verbose info */
 static int all;	/* Any valid ref can be used */
 static int tags;	/* Allow lightweight tags */
@@ -41,7 +65,8 @@ static struct string_list patterns = STRING_LIST_INIT_NODUP;
 static struct string_list exclude_patterns = STRING_LIST_INIT_NODUP;
 static int always;
 static const char *suffix, *dirty, *broken;
-static struct commit_names commit_names;
+static struct commit_names __commit_names;
+#endif
 
 /* diff-index command arguments to check if working tree is dirty. */
 static const char *diff_index_args[] = {
@@ -334,13 +359,13 @@ static void describe_commit(struct object_id *oid, struct strbuf *dst)
 		struct commit *c;
 		struct commit_name *n;
 
-		init_commit_names(&commit_names);
+		init_commit_names(&__commit_names);
 		hashmap_for_each_entry(&names, &iter, n,
 					entry /* member name */) {
 			c = lookup_commit_reference_gently(the_repository,
 							   &n->peeled, 1);
 			if (c)
-				*commit_names_at(&commit_names, c) = n;
+				*commit_names_at(&__commit_names, c) = n;
 		}
 		have_util = 1;
 	}
@@ -354,7 +379,7 @@ static void describe_commit(struct object_id *oid, struct strbuf *dst)
 		struct commit_name **slot;
 
 		seen_commits++;
-		slot = commit_names_peek(&commit_names, c);
+		slot = commit_names_peek(&__commit_names, c);
 		n = slot ? *slot : NULL;
 		if (n) {
 			if (!tags && !all && n->prio < 2) {
@@ -440,7 +465,11 @@ static void describe_commit(struct object_id *oid, struct strbuf *dst)
 	free_commit_list(list);
 
 	if (debug) {
+#ifdef __VSF__
+# define label_width (git_ctx->builtin_describe.describe_commit.__label_width)
+#else
 		static int label_width = -1;
+#endif
 		if (label_width < 0) {
 			int i, w;
 			for (i = 0; i < ARRAY_SIZE(prio_names); i++) {
@@ -463,6 +492,9 @@ static void describe_commit(struct object_id *oid, struct strbuf *dst)
 				max_candidates, max_candidates,
 				oid_to_hex(&gave_up_on->object.oid));
 		}
+#ifdef __VSF__
+# undef label_width
+#endif
 	}
 
 	append_name(all_matches[0].name, dst);
diff --git a/builtin/diff-tree.c b/builtin/diff-tree.c
index 0e0ac1f167..f25bfd4561 100644
--- a/builtin/diff-tree.c
+++ b/builtin/diff-tree.c
@@ -8,7 +8,15 @@
 #include "submodule.h"
 #include "repository.h"
 
+#ifdef __VSF__
+# include "git_port_vsf.h"
+#endif
+
+#ifdef __VSF__
+# define log_tree_opt (git_ctx->builtin_diff_tree.__log_tree_opt)
+#else
 static struct rev_info log_tree_opt;
+#endif
 
 static int diff_tree_commit_oid(const struct object_id *oid)
 {
@@ -107,7 +115,11 @@ int cmd_diff_tree(int argc, const char **argv, const char *prefix)
 {
 	char line[1000];
 	struct object *tree1, *tree2;
+#ifdef __VSF__
+# define opt (git_ctx->builtin_diff_tree.cmd_diff_tree.__opt)
+#else
 	static struct rev_info *opt = &log_tree_opt;
+#endif
 	struct setup_revision_opt s_r_opt;
 	struct userformat_want w;
 	int read_stdin = 0;
@@ -220,4 +232,7 @@ int cmd_diff_tree(int argc, const char **argv, const char *prefix)
 	}
 
 	return diff_result_code(&opt->diffopt, 0);
+#ifdef __VSF__
+# undef opt
+#endif
 }
diff --git a/builtin/difftool.c b/builtin/difftool.c
index c79fbbf67e..9645170207 100644
--- a/builtin/difftool.c
+++ b/builtin/difftool.c
@@ -25,7 +25,15 @@
 #include "dir.h"
 #include "entry.h"
 
+#ifdef __VSF__
+# include "git_port_vsf.h"
+#endif
+
+#ifdef __VSF__
+# define trust_exit_code (git_ctx->builtin_difftool.__trust_exit_code)
+#else
 static int trust_exit_code;
+#endif
 
 static const char *const builtin_difftool_usage[] = {
 	N_("git difftool [<options>] [<commit> [<commit>]] [--] [<path>...]"),
@@ -684,7 +692,12 @@ int cmd_difftool(int argc, const char **argv, const char *prefix)
 {
 	int use_gui_tool = 0, dir_diff = 0, prompt = -1, symlinks = 0,
 	    tool_help = 0, no_index = 0;
+#ifdef __VSF__
+# define difftool_cmd (git_ctx->builtin_difftool.cmd_difftool.__difftool_cmd)
+# define extcmd (git_ctx->builtin_difftool.cmd_difftool.__extcmd)
+#else
 	static char *difftool_cmd = NULL, *extcmd = NULL;
+#endif
 	struct option builtin_difftool_options[] = {
 		OPT_BOOL('g', "gui", &use_gui_tool,
 			 N_("use `diff.guitool` instead of `diff.tool`")),
@@ -770,4 +783,8 @@ int cmd_difftool(int argc, const char **argv, const char *prefix)
 	if (dir_diff)
 		return run_dir_diff(extcmd, symlinks, prefix, &child);
 	return run_file_diff(prompt, prefix, &child);
+#ifdef __VSF__
+# undef difftool_cmd
+# undef extcmd
+#endif
 }
diff --git a/builtin/fast-export.c b/builtin/fast-export.c
index 9f1c730e58..45a2b40d77 100644
--- a/builtin/fast-export.c
+++ b/builtin/fast-export.c
@@ -25,11 +25,34 @@
 #include "blob.h"
 #include "commit-slab.h"
 
+#ifdef __VSF__
+# include "git_port_vsf.h"
+#endif
+
 static const char *fast_export_usage[] = {
 	N_("git fast-export [rev-list-opts]"),
 	NULL
 };
 
+#ifdef __VSF__
+# define progress (git_ctx->builtin_fast_export.__progress)
+# define signed_tag_mode (git_ctx->builtin_fast_export.__signed_tag_mode)
+# define tag_of_filtered_mode (git_ctx->builtin_fast_export.__tag_of_filtered_mode)
+# define reencode_mode (git_ctx->builtin_fast_export.__reencode_mode)
+# define fake_missing_tagger (git_ctx->builtin_fast_export.__fake_missing_tagger)
+# define use_done_feature (git_ctx->builtin_fast_export.__use_done_feature)
+# define no_data (git_ctx->builtin_fast_export.__no_data)
+# define full_tree (git_ctx->builtin_fast_export.__full_tree)
+# define reference_excluded_commits (git_ctx->builtin_fast_export.__reference_excluded_commits)
+# define show_original_ids (git_ctx->builtin_fast_export.__show_original_ids)
+# define mark_tags (git_ctx->builtin_fast_export.__mark_tags)
+# define extra_refs (git_ctx->builtin_fast_export.__extra_refs)
+# define tag_refs (git_ctx->builtin_fast_export.__tag_refs)
+# define refspecs (git_ctx->builtin_fast_export.__refspecs)
+# define anonymize (git_ctx->builtin_fast_export.__anonymize)
+# define anonymized_seeds (git_ctx->builtin_fast_export.__anonymized_seeds)
+# define revision_sources (git_ctx->builtin_fast_export.__revision_sources)
+#else
 static int progress;
 static enum { SIGNED_TAG_ABORT, VERBATIM, WARN, WARN_STRIP, STRIP } signed_tag_mode = SIGNED_TAG_ABORT;
 static enum { TAG_FILTERING_ABORT, DROP, REWRITE } tag_of_filtered_mode = TAG_FILTERING_ABORT;
@@ -47,6 +70,7 @@ static struct refspec refspecs = REFSPEC_INIT_FETCH;
 static int anonymize;
 static struct hashmap anonymized_seeds;
 static struct revision_sources revision_sources;
+#endif
 
 static int parse_opt_signed_tag_mode(const struct option *opt,
 				     const char *arg, int unset)
@@ -105,8 +129,13 @@ static int parse_opt_reencode_mode(const struct option *opt,
 	return 0;
 }
 
+#ifdef __VSF__
+# define idnums (git_ctx->builtin_fast_export.__idnums)
+# define last_idnum (git_ctx->builtin_fast_export.__last_idnum)
+#else
 static struct decoration idnums;
 static uint32_t last_idnum;
+#endif
 struct anonymized_entry {
 	struct hashmap_entry hash;
 	const char *anon;
@@ -246,11 +275,18 @@ static struct commit *rewrite_commit(struct commit *p)
 
 static void show_progress(void)
 {
+#ifdef __VSF__
+# define counter (git_ctx->builtin_fast_export.show_progress.__counter)
+#else
 	static int counter = 0;
+#endif
 	if (!progress)
 		return;
 	if ((++counter % progress) == 0)
 		printf("progress %d objects\n", counter);
+#ifdef __VSF__
+# undef counter
+#endif
 }
 
 /*
@@ -266,11 +302,18 @@ static void show_progress(void)
  */
 static char *anonymize_blob(unsigned long *size)
 {
+#ifdef __VSF__
+# define counter (git_ctx->builtin_fast_export.anonymize_blob.__counter)
+#else
 	static int counter;
+#endif
 	struct strbuf out = STRBUF_INIT;
 	strbuf_addf(&out, "anonymous blob %d", counter++);
 	*size = out.len;
 	return strbuf_detach(&out, NULL);
+#ifdef __VSF__
+# undef counter
+#endif
 }
 
 static void export_blob(const struct object_id *oid)
@@ -369,10 +412,17 @@ static void print_path_1(const char *path)
 
 static char *anonymize_path_component(void *data)
 {
+#ifdef __VSF__
+# define counter (git_ctx->builtin_fast_export.anonymize_path_component.__counter)
+#else
 	static int counter;
+#endif
 	struct strbuf out = STRBUF_INIT;
 	strbuf_addf(&out, "path%d", counter++);
 	return strbuf_detach(&out, NULL);
+#ifdef __VSF__
+# undef counter
+#endif
 }
 
 static void print_path(const char *path)
@@ -380,18 +430,31 @@ static void print_path(const char *path)
 	if (!anonymize)
 		print_path_1(path);
 	else {
+#ifdef __VSF__
+# define paths (git_ctx->builtin_fast_export.print_path.__paths)
+# define anon (git_ctx->builtin_fast_export.print_path.__anon)
+#else
 		static struct hashmap paths;
 		static struct strbuf anon = STRBUF_INIT;
+#endif
 
 		anonymize_path(&anon, path, &paths, anonymize_path_component);
 		print_path_1(anon.buf);
 		strbuf_reset(&anon);
+#ifdef __VSF__
+# undef paths
+# undef anon
+#endif
 	}
 }
 
 static char *generate_fake_oid(void *data)
 {
+#ifdef __VSF__
+# define counter (git_ctx->builtin_fast_export.generate_fake_oid.__counter)
+#else
 	static uint32_t counter = 1; /* avoid null oid */
+#endif
 	const unsigned hashsz = the_hash_algo->rawsz;
 	struct object_id oid;
 	char *hex = xmallocz(GIT_MAX_HEXSZ);
@@ -399,13 +462,23 @@ static char *generate_fake_oid(void *data)
 	oidclr(&oid);
 	put_be32(oid.hash + hashsz - 4, counter++);
 	return oid_to_hex_r(hex, &oid);
+#ifdef __VSF__
+# undef counter
+#endif
 }
 
 static const char *anonymize_oid(const char *oid_hex)
 {
+#ifdef __VSF__
+# define objs (git_ctx->builtin_fast_export.anonymize_oid.__objs)
+#else
 	static struct hashmap objs;
+#endif
 	size_t len = strlen(oid_hex);
 	return anonymize_str(&objs, generate_fake_oid, oid_hex, len, NULL);
+#ifdef __VSF__
+# undef objs
+#endif
 }
 
 static void show_filemodify(struct diff_queue_struct *q,
@@ -504,10 +577,17 @@ static const char *find_encoding(const char *begin, const char *end)
 
 static char *anonymize_ref_component(void *data)
 {
+#ifdef __VSF__
+# define counter (git_ctx->builtin_fast_export.anonymize_ref_component.__counter)
+#else
 	static int counter;
+#endif
 	struct strbuf out = STRBUF_INIT;
 	strbuf_addf(&out, "ref%d", counter++);
 	return strbuf_detach(&out, NULL);
+#ifdef __VSF__
+# undef counter
+#endif
 }
 
 static const char *anonymize_refname(const char *refname)
@@ -522,8 +602,13 @@ static const char *anonymize_refname(const char *refname)
 		"refs/remotes/",
 		"refs/"
 	};
+#ifdef __VSF__
+# define refs (git_ctx->builtin_fast_export.anonymize_refname.__refs)
+# define anon (git_ctx->builtin_fast_export.anonymize_refname.__anon)
+#else
 	static struct hashmap refs;
 	static struct strbuf anon = STRBUF_INIT;
+#endif
 	int i;
 
 	strbuf_reset(&anon);
@@ -536,6 +621,10 @@ static const char *anonymize_refname(const char *refname)
 
 	anonymize_path(&anon, refname, &refs, anonymize_ref_component);
 	return anon.buf;
+#ifdef __VSF__
+# undef refs
+# undef anon
+#endif
 }
 
 /*
@@ -544,17 +633,31 @@ static const char *anonymize_refname(const char *refname)
  */
 static char *anonymize_commit_message(const char *old)
 {
+#ifdef __VSF__
+# define counter (git_ctx->builtin_fast_export.anonymize_commit_message.__counter)
+#else
 	static int counter;
+#endif
 	return xstrfmt("subject %d\n\nbody\n", counter++);
+#ifdef __VSF__
+# undef counter
+#endif
 }
 
 static char *anonymize_ident(void *data)
 {
+#ifdef __VSF__
+# define counter (git_ctx->builtin_fast_export.anonymize_ident.__counter)
+#else
 	static int counter;
+#endif
 	struct strbuf out = STRBUF_INIT;
 	strbuf_addf(&out, "User %d <user%d@example.com>", counter, counter);
 	counter++;
 	return strbuf_detach(&out, NULL);
+#ifdef __VSF__
+# undef counter
+#endif
 }
 
 /*
@@ -564,9 +667,15 @@ static char *anonymize_ident(void *data)
  */
 static void anonymize_ident_line(const char **beg, const char **end)
 {
+#ifdef __VSF__
+# define idents (git_ctx->builtin_fast_export.anonymize_ident_line.__idents)
+# define buffers (git_ctx->builtin_fast_export.anonymize_ident_line.__buffers)
+# define which_buffer (git_ctx->builtin_fast_export.anonymize_ident_line.__which_buffer)
+#else
 	static struct hashmap idents;
 	static struct strbuf buffers[] = { STRBUF_INIT, STRBUF_INIT };
 	static unsigned which_buffer;
+#endif
 
 	struct strbuf *out;
 	struct ident_split split;
@@ -601,6 +710,11 @@ static void anonymize_ident_line(const char **beg, const char **end)
 
 	*beg = out->buf;
 	*end = out->buf + out->len;
+#ifdef __VSF__
+# undef idents
+# undef buffers
+# undef which_buffer
+#endif
 }
 
 static void handle_commit(struct commit *commit, struct rev_info *rev,
@@ -734,10 +848,17 @@ static void handle_commit(struct commit *commit, struct rev_info *rev,
 
 static char *anonymize_tag(void *data)
 {
+#ifdef __VSF__
+# define counter (git_ctx->builtin_fast_export.anonymize_tag.__counter)
+#else
 	static int counter;
+#endif
 	struct strbuf out = STRBUF_INIT;
 	strbuf_addf(&out, "tag message %d", counter++);
 	return strbuf_detach(&out, NULL);
+#ifdef __VSF__
+# undef counter
+#endif
 }
 
 
diff --git a/builtin/fast-import.c b/builtin/fast-import.c
index 2b2e28bad7..22b1602ac8 100644
--- a/builtin/fast-import.c
+++ b/builtin/fast-import.c
@@ -20,6 +20,10 @@
 #include "commit-reach.h"
 #include "khash.h"
 
+#ifdef __VSF__
+# include "git_port_vsf.h"
+#endif
+
 #define PACK_ID_BITS 16
 #define MAX_PACK_ID ((1<<PACK_ID_BITS)-1)
 #define DEPTH_BITS 13
@@ -77,12 +81,14 @@ struct mark_set {
 	unsigned int shift;
 };
 
+#ifndef __VSF__
 struct last_object {
 	struct strbuf data;
 	off_t offset;
 	unsigned int depth;
 	unsigned no_swap : 1;
 };
+#endif
 
 struct atom_str {
 	struct atom_str *next_atom;
@@ -112,9 +118,9 @@ struct avail_tree_content {
 	struct avail_tree_content *next_avail;
 };
 
-struct branch {
-	struct branch *table_next_branch;
-	struct branch *active_next_branch;
+struct __branch {
+	struct __branch *table_next_branch;
+	struct __branch *active_next_branch;
 	const char *name;
 	struct tree_entry branch_tree;
 	uintmax_t last_commit;
@@ -137,6 +143,7 @@ struct hash_list {
 	struct object_id oid;
 };
 
+#ifndef __VSF__
 typedef enum {
 	WHENSPEC_RAW = 1,
 	WHENSPEC_RAW_PERMISSIVE,
@@ -149,10 +156,84 @@ struct recent_command {
 	struct recent_command *next;
 	char *buf;
 };
+#endif
 
 typedef void (*mark_set_inserter_t)(struct mark_set **s, struct object_id *oid, uintmax_t mark);
 typedef void (*each_mark_fn_t)(uintmax_t mark, void *obj, void *cbp);
 
+#ifdef __VSF__
+# define max_depth (git_ctx->builtin_fast_import.__max_depth)
+# define max_packsize (git_ctx->builtin_fast_import.__max_packsize)
+# define unpack_limit (git_ctx->builtin_fast_import.__unpack_limit)
+# define force_update (git_ctx->builtin_fast_import.__force_update)
+# define alloc_count (git_ctx->builtin_fast_import.__alloc_count)
+# define marks_set_count (git_ctx->builtin_fast_import.__marks_set_count)
+# define object_count_by_type (git_ctx->builtin_fast_import.__object_count_by_type)
+# define duplicate_count_by_type (git_ctx->builtin_fast_import.__duplicate_count_by_type)
+# define delta_count_by_type (git_ctx->builtin_fast_import.__delta_count_by_type)
+# define delta_count_attempts_by_type (git_ctx->builtin_fast_import.__delta_count_attempts_by_type)
+# define object_count (git_ctx->builtin_fast_import.__object_count)
+# define branch_count (git_ctx->builtin_fast_import.__branch_count)
+# define branch_load_count (git_ctx->builtin_fast_import.__branch_load_count)
+# define failure (git_ctx->builtin_fast_import.__failure)
+# define pack_edges (git_ctx->builtin_fast_import.__pack_edges)
+# define show_stats (git_ctx->builtin_fast_import.__show_stats)
+# define global_argc (git_ctx->builtin_fast_import.__global_argc)
+# define global_argv (git_ctx->builtin_fast_import.__global_argv)
+# define fi_mem_pool (git_ctx->builtin_fast_import.__fi_mem_pool)
+# define atom_table_sz (git_ctx->builtin_fast_import.__atom_table_sz)
+# define atom_cnt (git_ctx->builtin_fast_import.__atom_cnt)
+# define atom_table (git_ctx->builtin_fast_import.__atom_table)
+# define pack_idx_opts (git_ctx->builtin_fast_import.__pack_idx_opts)
+# define __pack_id (git_ctx->builtin_fast_import.__pack_id)
+# define pack_file (git_ctx->builtin_fast_import.__pack_file)
+# define pack_data (git_ctx->builtin_fast_import.__pack_data)
+# define all_packs (git_ctx->builtin_fast_import.__all_packs)
+# define __pack_size (git_ctx->builtin_fast_import.__pack_size)
+# define object_entry_alloc (git_ctx->builtin_fast_import.__object_entry_alloc)
+# define blocks (git_ctx->builtin_fast_import.__blocks)
+# define object_table (git_ctx->builtin_fast_import.__object_table)
+# define __marks (git_ctx->builtin_fast_import.__marks)
+# define export_marks_file (git_ctx->builtin_fast_import.__export_marks_file)
+# define import_marks_file (git_ctx->builtin_fast_import.__import_marks_file)
+# define import_marks_file_from_stream (git_ctx->builtin_fast_import.__import_marks_file_from_stream)
+# define import_marks_file_ignore_missing (git_ctx->builtin_fast_import.__import_marks_file_ignore_missing)
+# define import_marks_file_done (git_ctx->builtin_fast_import.__import_marks_file_done)
+# define relative_marks_paths (git_ctx->builtin_fast_import.__relative_marks_paths)
+# define last_blob (git_ctx->builtin_fast_import.__last_blob)
+# define tree_entry_alloc (git_ctx->builtin_fast_import.__tree_entry_alloc)
+# define avail_tree_entry (git_ctx->builtin_fast_import.__avail_tree_entry)
+# define avail_tree_table_sz (git_ctx->builtin_fast_import.__avail_tree_table_sz)
+# define avail_tree_table (git_ctx->builtin_fast_import.__avail_tree_table)
+# define tree_entry_allocd (git_ctx->builtin_fast_import.__tree_entry_allocd)
+# define old_tree (git_ctx->builtin_fast_import.__old_tree)
+# define new_tree (git_ctx->builtin_fast_import.__new_tree)
+# define max_active_branches (git_ctx->builtin_fast_import.__max_active_branches)
+# define cur_active_branches (git_ctx->builtin_fast_import.__cur_active_branches)
+# define branch_table_sz (git_ctx->builtin_fast_import.__branch_table_sz)
+# define branch_table (git_ctx->builtin_fast_import.__branch_table)
+# define active_branches (git_ctx->builtin_fast_import.__active_branches)
+# define first_tag (git_ctx->builtin_fast_import.__first_tag)
+# define last_tag (git_ctx->builtin_fast_import.__last_tag)
+# define whenspec (git_ctx->builtin_fast_import.__whenspec)
+# define command_buf (git_ctx->builtin_fast_import.__command_buf)
+# define unread_command_buf (git_ctx->builtin_fast_import.__unread_command_buf)
+# define cmd_hist (git_ctx->builtin_fast_import.__cmd_hist)
+# define cmd_tail (git_ctx->builtin_fast_import.__cmd_tail)
+# define rc_free (git_ctx->builtin_fast_import.__rc_free)
+# define cmd_save (git_ctx->builtin_fast_import.__cmd_save)
+# define next_mark (git_ctx->builtin_fast_import.__next_mark)
+# define next_mark (git_ctx->builtin_fast_import.__next_mark)
+# define new_data (git_ctx->builtin_fast_import.__new_data)
+# define seen_data_command (git_ctx->builtin_fast_import.__seen_data_command)
+# define require_explicit_termination (git_ctx->builtin_fast_import.__require_explicit_termination)
+# define allow_unsafe_features (git_ctx->builtin_fast_import.__allow_unsafe_features)
+# define checkpoint_requested (git_ctx->builtin_fast_import.__checkpoint_requested)
+# define sub_marks_from (git_ctx->builtin_fast_import.__sub_marks_from)
+# define sub_marks_to (git_ctx->builtin_fast_import.__sub_marks_to)
+# define sub_oid_map (git_ctx->builtin_fast_import.__sub_oid_map)
+# define cat_blob_fd (git_ctx->builtin_fast_import.__cat_blob_fd)
+#else
 /* Configured limits on output */
 static unsigned long max_depth = 50;
 static off_t max_packsize;
@@ -186,17 +267,17 @@ static struct atom_str **atom_table;
 
 /* The .pack file being generated */
 static struct pack_idx_option pack_idx_opts;
-static unsigned int pack_id;
+static unsigned int __pack_id;
 static struct hashfile *pack_file;
 static struct packed_git *pack_data;
 static struct packed_git **all_packs;
-static off_t pack_size;
+static off_t __pack_size;
 
 /* Table of objects we've written. */
 static unsigned int object_entry_alloc = 5000;
 static struct object_entry_pool *blocks;
 static struct hashmap object_table;
-static struct mark_set *marks;
+static struct mark_set *__marks;
 static const char *export_marks_file;
 static const char *import_marks_file;
 static int import_marks_file_from_stream;
@@ -220,8 +301,8 @@ static struct strbuf new_tree = STRBUF_INIT;
 static unsigned long max_active_branches = 5;
 static unsigned long cur_active_branches;
 static unsigned long branch_table_sz = 1039;
-static struct branch **branch_table;
-static struct branch *active_branches;
+static struct __branch **branch_table;
+static struct __branch *active_branches;
 
 /* Tag data */
 static struct tag *first_tag;
@@ -251,11 +332,12 @@ static kh_oid_map_t *sub_oid_map;
 
 /* Where to write output of cat-blob commands */
 static int cat_blob_fd = STDOUT_FILENO;
+#endif
 
 static void parse_argv(void);
 static void parse_get_mark(const char *p);
 static void parse_cat_blob(const char *p);
-static void parse_ls(const char *p, struct branch *b);
+static void parse_ls(const char *p, struct __branch *b);
 
 static void for_each_mark(struct mark_set *m, uintmax_t base, each_mark_fn_t callback, void *p)
 {
@@ -280,7 +362,7 @@ static void dump_marks_fn(uintmax_t mark, void *object, void *cbp) {
 	fprintf(f, ":%" PRIuMAX " %s\n", mark, oid_to_hex(&e->idx.oid));
 }
 
-static void write_branch_report(FILE *rpt, struct branch *b)
+static void write_branch_report(FILE *rpt, struct __branch *b)
 {
 	fprintf(rpt, "%s:\n", b->name);
 
@@ -312,7 +394,7 @@ static void write_crash_report(const char *err)
 {
 	char *loc = git_pathdup("fast_import_crash_%"PRIuMAX, (uintmax_t) getpid());
 	FILE *rpt = fopen(loc, "w");
-	struct branch *b;
+	struct __branch *b;
 	unsigned long lu;
 	struct recent_command *rc;
 
@@ -386,7 +468,7 @@ static void write_crash_report(const char *err)
 	if (export_marks_file)
 		fprintf(rpt, "  exported to %s\n", export_marks_file);
 	else
-		for_each_mark(marks, 0, dump_marks_fn, rpt);
+		for_each_mark(__marks, 0, dump_marks_fn, rpt);
 
 	fputc('\n', rpt);
 	fputs("-------------------\n", rpt);
@@ -508,7 +590,7 @@ static void invalidate_pack_id(unsigned int id)
 	}
 
 	for (lu = 0; lu < branch_table_sz; lu++) {
-		struct branch *b;
+		struct __branch *b;
 
 		for (b = branch_table[lu]; b; b = b->table_next_branch)
 			if (b->pack_id == id)
@@ -589,10 +671,10 @@ static struct atom_str *to_atom(const char *s, unsigned short len)
 	return c;
 }
 
-static struct branch *lookup_branch(const char *name)
+static struct __branch *lookup_branch(const char *name)
 {
 	unsigned int hc = hc_str(name, strlen(name)) % branch_table_sz;
-	struct branch *b;
+	struct __branch *b;
 
 	for (b = branch_table[hc]; b; b = b->table_next_branch)
 		if (!strcmp(name, b->name))
@@ -600,17 +682,17 @@ static struct branch *lookup_branch(const char *name)
 	return NULL;
 }
 
-static struct branch *new_branch(const char *name)
+static struct __branch *new_branch(const char *name)
 {
 	unsigned int hc = hc_str(name, strlen(name)) % branch_table_sz;
-	struct branch *b = lookup_branch(name);
+	struct __branch *b = lookup_branch(name);
 
 	if (b)
 		die("Invalid attempt to create duplicate branch: %s", name);
 	if (check_refname_format(name, REFNAME_ALLOW_ONELEVEL))
 		die("Branch name doesn't conform to GIT standards: %s", name);
 
-	b = mem_pool_calloc(&fi_mem_pool, 1, sizeof(struct branch));
+	b = mem_pool_calloc(&fi_mem_pool, 1, sizeof(struct __branch));
 	b->name = mem_pool_strdup(&fi_mem_pool, name);
 	b->table_next_branch = branch_table[hc];
 	b->branch_tree.versions[0].mode = S_IFDIR;
@@ -754,11 +836,11 @@ static void start_packfile(void)
 	pack_file = hashfd(pack_fd, p->pack_name);
 
 	pack_data = p;
-	pack_size = write_pack_header(pack_file, 0);
+	__pack_size = write_pack_header(pack_file, 0);
 	object_count = 0;
 
-	REALLOC_ARRAY(all_packs, pack_id + 1);
-	all_packs[pack_id] = p;
+	REALLOC_ARRAY(all_packs, __pack_id + 1);
+	all_packs[__pack_id] = p;
 }
 
 static const char *create_index(void)
@@ -773,7 +855,7 @@ static const char *create_index(void)
 	c = idx;
 	for (o = blocks; o; o = o->next_pool)
 		for (e = o->next_free; e-- != o->entries;)
-			if (pack_id == e->pack_id)
+			if (__pack_id == e->pack_id)
 				*c++ = &e->idx;
 	last = idx + object_count;
 	if (c != last)
@@ -815,7 +897,7 @@ static void unkeep_all_packs(void)
 	struct strbuf name = STRBUF_INIT;
 	int k;
 
-	for (k = 0; k < pack_id; k++) {
+	for (k = 0; k < __pack_id; k++) {
 		struct packed_git *p = all_packs[k];
 		odb_pack_name(&name, p->hash, "keep");
 		unlink_or_warn(name.buf);
@@ -842,7 +924,11 @@ static int loosen_small_pack(const struct packed_git *p)
 
 static void end_packfile(void)
 {
+#ifdef __VSF__
+# define running (git_ctx->builtin_fast_import.end_packfile.__running)
+#else
 	static int running;
+#endif
 
 	if (running || !pack_data)
 		return;
@@ -854,18 +940,18 @@ static void end_packfile(void)
 		struct object_id cur_pack_oid;
 		char *idx_name;
 		int i;
-		struct branch *b;
+		struct __branch *b;
 		struct tag *t;
 
 		close_pack_windows(pack_data);
 		finalize_hashfile(pack_file, cur_pack_oid.hash, 0);
 		fixup_pack_header_footer(pack_data->pack_fd, pack_data->hash,
 					 pack_data->pack_name, object_count,
-					 cur_pack_oid.hash, pack_size);
+					 cur_pack_oid.hash, __pack_size);
 
 		if (object_count <= unpack_limit) {
 			if (!loosen_small_pack(pack_data)) {
-				invalidate_pack_id(pack_id);
+				invalidate_pack_id(__pack_id);
 				goto discard_pack;
 			}
 		}
@@ -877,7 +963,7 @@ static void end_packfile(void)
 		new_p = add_packed_git(idx_name, strlen(idx_name), 1);
 		if (!new_p)
 			die("core git rejected index %s", idx_name);
-		all_packs[pack_id] = new_p;
+		all_packs[__pack_id] = new_p;
 		install_packed_git(the_repository, new_p);
 		free(idx_name);
 
@@ -886,13 +972,13 @@ static void end_packfile(void)
 			fprintf(pack_edges, "%s:", new_p->pack_name);
 			for (i = 0; i < branch_table_sz; i++) {
 				for (b = branch_table[i]; b; b = b->table_next_branch) {
-					if (b->pack_id == pack_id)
+					if (b->pack_id == __pack_id)
 						fprintf(pack_edges, " %s",
 							oid_to_hex(&b->oid));
 				}
 			}
 			for (t = first_tag; t; t = t->next_tag) {
-				if (t->pack_id == pack_id)
+				if (t->pack_id == __pack_id)
 					fprintf(pack_edges, " %s",
 						oid_to_hex(&t->oid));
 			}
@@ -900,7 +986,7 @@ static void end_packfile(void)
 			fflush(pack_edges);
 		}
 
-		pack_id++;
+		__pack_id++;
 	}
 	else {
 discard_pack:
@@ -914,6 +1000,9 @@ static void end_packfile(void)
 	strbuf_release(&last_blob.data);
 	last_blob.offset = 0;
 	last_blob.depth = 0;
+#ifdef __VSF__
+# undef running
+#endif
 }
 
 static void cycle_packfile(void)
@@ -948,7 +1037,7 @@ static int store_object(
 
 	e = insert_object(&oid);
 	if (mark)
-		insert_mark(&marks, mark, e);
+		insert_mark(&__marks, mark, e);
 	if (e->idx.offset) {
 		duplicate_count_by_type[type]++;
 		return 1;
@@ -987,11 +1076,11 @@ static int store_object(
 
 	/* Determine if we should auto-checkpoint. */
 	if ((max_packsize
-		&& (pack_size + PACK_SIZE_THRESHOLD + s.total_out) > max_packsize)
-		|| (pack_size + PACK_SIZE_THRESHOLD + s.total_out) < pack_size) {
+		&& (__pack_size + PACK_SIZE_THRESHOLD + s.total_out) > max_packsize)
+		|| (__pack_size + PACK_SIZE_THRESHOLD + s.total_out) < __pack_size) {
 
 		/* This new object needs to *not* have the current pack_id. */
-		e->pack_id = pack_id + 1;
+		e->pack_id = __pack_id + 1;
 		cycle_packfile();
 
 		/* We cannot carry a delta into the new pack. */
@@ -1010,8 +1099,8 @@ static int store_object(
 	}
 
 	e->type = type;
-	e->pack_id = pack_id;
-	e->idx.offset = pack_size;
+	e->pack_id = __pack_id;
+	e->idx.offset = __pack_size;
 	object_count++;
 	object_count_by_type[type]++;
 
@@ -1027,23 +1116,23 @@ static int store_object(
 		hdrlen = encode_in_pack_object_header(hdr, sizeof(hdr),
 						      OBJ_OFS_DELTA, deltalen);
 		hashwrite(pack_file, hdr, hdrlen);
-		pack_size += hdrlen;
+		__pack_size += hdrlen;
 
 		hdr[pos] = ofs & 127;
 		while (ofs >>= 7)
 			hdr[--pos] = 128 | (--ofs & 127);
 		hashwrite(pack_file, hdr + pos, sizeof(hdr) - pos);
-		pack_size += sizeof(hdr) - pos;
+		__pack_size += sizeof(hdr) - pos;
 	} else {
 		e->depth = 0;
 		hdrlen = encode_in_pack_object_header(hdr, sizeof(hdr),
 						      type, dat->len);
 		hashwrite(pack_file, hdr, hdrlen);
-		pack_size += hdrlen;
+		__pack_size += hdrlen;
 	}
 
 	hashwrite(pack_file, out, s.total_out);
-	pack_size += s.total_out;
+	__pack_size += s.total_out;
 
 	e->idx.crc32 = crc32_end(pack_file);
 
@@ -1065,7 +1154,7 @@ static void truncate_pack(struct hashfile_checkpoint *checkpoint)
 {
 	if (hashfile_truncate(pack_file, checkpoint))
 		die_errno("cannot truncate pack to skip duplicate");
-	pack_size = checkpoint->offset;
+	__pack_size = checkpoint->offset;
 }
 
 static void stream_blob(uintmax_t len, struct object_id *oidout, uintmax_t mark)
@@ -1084,8 +1173,8 @@ static void stream_blob(uintmax_t len, struct object_id *oidout, uintmax_t mark)
 
 	/* Determine if we should auto-checkpoint. */
 	if ((max_packsize
-		&& (pack_size + PACK_SIZE_THRESHOLD + len) > max_packsize)
-		|| (pack_size + PACK_SIZE_THRESHOLD + len) < pack_size)
+		&& (__pack_size + PACK_SIZE_THRESHOLD + len) > max_packsize)
+		|| (__pack_size + PACK_SIZE_THRESHOLD + len) < __pack_size)
 		cycle_packfile();
 
 	hashfile_checkpoint(pack_file, &checkpoint);
@@ -1123,7 +1212,7 @@ static void stream_blob(uintmax_t len, struct object_id *oidout, uintmax_t mark)
 		if (!s.avail_out || status == Z_STREAM_END) {
 			size_t n = s.next_out - out_buf;
 			hashwrite(pack_file, out_buf, n);
-			pack_size += n;
+			__pack_size += n;
 			s.next_out = out_buf;
 			s.avail_out = out_sz;
 		}
@@ -1146,7 +1235,7 @@ static void stream_blob(uintmax_t len, struct object_id *oidout, uintmax_t mark)
 	e = insert_object(&oid);
 
 	if (mark)
-		insert_mark(&marks, mark, e);
+		insert_mark(&__marks, mark, e);
 
 	if (e->idx.offset) {
 		duplicate_count_by_type[OBJ_BLOB]++;
@@ -1163,7 +1252,7 @@ static void stream_blob(uintmax_t len, struct object_id *oidout, uintmax_t mark)
 	} else {
 		e->depth = 0;
 		e->type = OBJ_BLOB;
-		e->pack_id = pack_id;
+		e->pack_id = __pack_id;
 		e->idx.offset = offset;
 		e->idx.crc32 = crc32_end(pack_file);
 		object_count++;
@@ -1198,7 +1287,7 @@ static void *gfi_unpack_entry(
 {
 	enum object_type type;
 	struct packed_git *p = all_packs[oe->pack_id];
-	if (p == pack_data && p->pack_size < (pack_size + the_hash_algo->rawsz)) {
+	if (p == pack_data && p->pack_size < (__pack_size + the_hash_algo->rawsz)) {
 		/* The object is stored in the packfile we are writing to
 		 * and we have modified it since the last time we scanned
 		 * back to read a previously written object.  If an old
@@ -1216,7 +1305,7 @@ static void *gfi_unpack_entry(
 		 * at least rawsz bytes within any window it maps.  But
 		 * we don't actually create the footer here.
 		 */
-		p->pack_size = pack_size + the_hash_algo->rawsz;
+		p->pack_size = __pack_size + the_hash_algo->rawsz;
 	}
 	return unpack_entry(the_repository, p, oe->idx.offset, &type, sizep);
 }
@@ -1352,7 +1441,7 @@ static void store_tree(struct tree_entry *root)
 
 	if (!(root->versions[0].mode & NO_DELTA))
 		le = find_object(&root->versions[0].oid);
-	if (S_ISDIR(root->versions[0].mode) && le && le->pack_id == pack_id) {
+	if (S_ISDIR(root->versions[0].mode) && le && le->pack_id == __pack_id) {
 		mktree(t, 0, &old_tree);
 		lo.data = old_tree;
 		lo.offset = le->idx.offset;
@@ -1594,7 +1683,7 @@ static int tree_content_get(
 	return 1;
 }
 
-static int update_branch(struct branch *b)
+static int update_branch(struct __branch *b)
 {
 	static const char *msg = "fast-import";
 	struct ref_transaction *transaction;
@@ -1644,7 +1733,7 @@ static int update_branch(struct branch *b)
 static void dump_branches(void)
 {
 	unsigned int i;
-	struct branch *b;
+	struct __branch *b;
 
 	for (i = 0; i < branch_table_sz; i++) {
 		for (b = branch_table[i]; b; b = b->table_next_branch)
@@ -1713,7 +1802,7 @@ static void dump_marks(void)
 		return;
 	}
 
-	for_each_mark(marks, 0, dump_marks_fn, f);
+	for_each_mark(__marks, 0, dump_marks_fn, f);
 	if (commit_lock_file(&mark_lock)) {
 		failure |= error_errno("Unable to write file %s",
 				       export_marks_file);
@@ -1776,7 +1865,7 @@ static void read_marks(void)
 		goto done; /* Marks file does not exist */
 	else
 		die_errno("cannot read '%s'", import_marks_file);
-	read_mark_file(&marks, f, insert_object_entry);
+	read_mark_file(&__marks, f, insert_object_entry);
 	fclose(f);
 done:
 	import_marks_file_done = 1;
@@ -1785,7 +1874,11 @@ static void read_marks(void)
 
 static int read_next_command(void)
 {
+#ifdef __VSF__
+# define stdin_eof (git_ctx->builtin_fast_import.read_next_command.__stdin_eof)
+#else
 	static int stdin_eof = 0;
+#endif
 
 	if (stdin_eof) {
 		unread_command_buf = 0;
@@ -1828,6 +1921,9 @@ static int read_next_command(void)
 			continue;
 		return 0;
 	}
+#ifdef __VSF__
+# undef stdin_eof
+#endif
 }
 
 static void skip_optional_lf(void)
@@ -1990,7 +2086,11 @@ static void parse_and_store_blob(
 	struct object_id *oidout,
 	uintmax_t mark)
 {
+#ifdef __VSF__
+# define buf (git_ctx->builtin_fast_import.parse_and_store_blob.__buf)
+#else
 	static struct strbuf buf = STRBUF_INIT;
+#endif
 	uintmax_t len;
 
 	if (parse_data(&buf, big_file_threshold, &len))
@@ -2004,6 +2104,9 @@ static void parse_and_store_blob(
 		stream_blob(len, oidout, mark);
 		skip_optional_lf();
 	}
+#ifdef __VSF__
+# undef buf
+#endif
 }
 
 static void parse_new_blob(void)
@@ -2019,7 +2122,7 @@ static void unload_one_branch(void)
 	while (cur_active_branches
 		&& cur_active_branches >= max_active_branches) {
 		uintmax_t min_commit = ULONG_MAX;
-		struct branch *e, *l = NULL, *p = NULL;
+		struct __branch *e, *l = NULL, *p = NULL;
 
 		for (e = active_branches; e; e = e->active_next_branch) {
 			if (e->last_commit < min_commit) {
@@ -2046,7 +2149,7 @@ static void unload_one_branch(void)
 	}
 }
 
-static void load_branch(struct branch *b)
+static void load_branch(struct __branch *b)
 {
 	load_tree(&b->branch_tree);
 	if (!b->active) {
@@ -2253,9 +2356,13 @@ static uintmax_t parse_mark_ref_space(const char **p)
 	return mark;
 }
 
-static void file_change_m(const char *p, struct branch *b)
+static void file_change_m(const char *p, struct __branch *b)
 {
+#ifdef __VSF__
+# define uq (git_ctx->builtin_fast_import.file_change_m.__uq)
+#else
 	static struct strbuf uq = STRBUF_INIT;
+#endif
 	const char *endp;
 	struct object_entry *oe;
 	struct object_id oid;
@@ -2280,7 +2387,7 @@ static void file_change_m(const char *p, struct branch *b)
 	}
 
 	if (*p == ':') {
-		oe = find_mark(marks, parse_mark_ref_space(&p));
+		oe = find_mark(__marks, parse_mark_ref_space(&p));
 		oidcpy(&oid, &oe->idx.oid);
 	} else if (skip_prefix(p, "inline ", &p)) {
 		inline_data = 1;
@@ -2357,11 +2464,18 @@ static void file_change_m(const char *p, struct branch *b)
 		return;
 	}
 	tree_content_set(&b->branch_tree, p, &oid, mode, NULL);
+#ifdef __VSF__
+# undef uq
+#endif
 }
 
-static void file_change_d(const char *p, struct branch *b)
+static void file_change_d(const char *p, struct __branch *b)
 {
+#ifdef __VSF__
+# define uq (git_ctx->builtin_fast_import.file_change_d.__uq)
+#else
 	static struct strbuf uq = STRBUF_INIT;
+#endif
 	const char *endp;
 
 	strbuf_reset(&uq);
@@ -2371,13 +2485,21 @@ static void file_change_d(const char *p, struct branch *b)
 		p = uq.buf;
 	}
 	tree_content_remove(&b->branch_tree, p, NULL, 1);
+#ifdef __VSF__
+# undef uq
+#endif
 }
 
-static void file_change_cr(const char *s, struct branch *b, int rename)
+static void file_change_cr(const char *s, struct __branch *b, int rename)
 {
 	const char *d;
+#ifdef __VSF__
+# define s_uq (git_ctx->builtin_fast_import.file_change_cr.__s_uq)
+# define d_uq (git_ctx->builtin_fast_import.file_change_cr.__d_uq)
+#else
 	static struct strbuf s_uq = STRBUF_INIT;
 	static struct strbuf d_uq = STRBUF_INIT;
+#endif
 	const char *endp;
 	struct tree_entry leaf;
 
@@ -2423,13 +2545,21 @@ static void file_change_cr(const char *s, struct branch *b, int rename)
 		&leaf.versions[1].oid,
 		leaf.versions[1].mode,
 		leaf.tree);
+#ifdef __VSF__
+# undef s_uq
+# undef d_uq
+#endif
 }
 
-static void note_change_n(const char *p, struct branch *b, unsigned char *old_fanout)
+static void note_change_n(const char *p, struct __branch *b, unsigned char *old_fanout)
 {
+#ifdef __VSF__
+# define uq (git_ctx->builtin_fast_import.note_change_n.__uq)
+#else
 	static struct strbuf uq = STRBUF_INIT;
+#endif
 	struct object_entry *oe;
-	struct branch *s;
+	struct __branch *s;
 	struct object_id oid, commit_oid;
 	char path[GIT_MAX_RAWSZ * 3];
 	uint16_t inline_data = 0;
@@ -2454,7 +2584,7 @@ static void note_change_n(const char *p, struct branch *b, unsigned char *old_fa
 	/* Now parse the notemodify command. */
 	/* <dataref> or 'inline' */
 	if (*p == ':') {
-		oe = find_mark(marks, parse_mark_ref_space(&p));
+		oe = find_mark(__marks, parse_mark_ref_space(&p));
 		oidcpy(&oid, &oe->idx.oid);
 	} else if (skip_prefix(p, "inline ", &p)) {
 		inline_data = 1;
@@ -2475,7 +2605,7 @@ static void note_change_n(const char *p, struct branch *b, unsigned char *old_fa
 		oidcpy(&commit_oid, &s->oid);
 	} else if (*p == ':') {
 		uintmax_t commit_mark = parse_mark_ref_eol(p);
-		struct object_entry *commit_oe = find_mark(marks, commit_mark);
+		struct object_entry *commit_oe = find_mark(__marks, commit_mark);
 		if (commit_oe->type != OBJ_COMMIT)
 			die("Mark :%" PRIuMAX " not a commit", commit_mark);
 		oidcpy(&commit_oid, &commit_oe->idx.oid);
@@ -2523,9 +2653,12 @@ static void note_change_n(const char *p, struct branch *b, unsigned char *old_fa
 	new_fanout = convert_num_notes_to_fanout(b->num_notes);
 	construct_path_with_fanout(oid_to_hex(&commit_oid), new_fanout, path);
 	tree_content_set(&b->branch_tree, path, &oid, S_IFREG | 0644, NULL);
+#ifdef __VSF__
+# undef uq
+#endif
 }
 
-static void file_change_deleteall(struct branch *b)
+static void file_change_deleteall(struct __branch *b)
 {
 	release_tree_content_recursive(b->branch_tree.tree);
 	oidclr(&b->branch_tree.versions[0].oid);
@@ -2534,7 +2667,7 @@ static void file_change_deleteall(struct branch *b)
 	b->num_notes = 0;
 }
 
-static void parse_from_commit(struct branch *b, char *buf, unsigned long size)
+static void parse_from_commit(struct __branch *b, char *buf, unsigned long size)
 {
 	if (!buf || size < the_hash_algo->hexsz + 6)
 		die("Not a valid commit: %s", oid_to_hex(&b->oid));
@@ -2545,7 +2678,7 @@ static void parse_from_commit(struct branch *b, char *buf, unsigned long size)
 	       &b->branch_tree.versions[1].oid);
 }
 
-static void parse_from_existing(struct branch *b)
+static void parse_from_existing(struct __branch *b)
 {
 	if (is_null_oid(&b->oid)) {
 		oidclr(&b->branch_tree.versions[0].oid);
@@ -2562,9 +2695,9 @@ static void parse_from_existing(struct branch *b)
 	}
 }
 
-static int parse_objectish(struct branch *b, const char *objectish)
+static int parse_objectish(struct __branch *b, const char *objectish)
 {
-	struct branch *s;
+	struct __branch *s;
 	struct object_id oid;
 
 	oidcpy(&oid, &b->branch_tree.versions[1].oid);
@@ -2579,7 +2712,7 @@ static int parse_objectish(struct branch *b, const char *objectish)
 		oidcpy(&b->branch_tree.versions[1].oid, t);
 	} else if (*objectish == ':') {
 		uintmax_t idnum = parse_mark_ref_eol(objectish);
-		struct object_entry *oe = find_mark(marks, idnum);
+		struct object_entry *oe = find_mark(__marks, idnum);
 		if (oe->type != OBJ_COMMIT)
 			die("Mark :%" PRIuMAX " not a commit", idnum);
 		if (!oideq(&b->oid, &oe->idx.oid)) {
@@ -2609,7 +2742,7 @@ static int parse_objectish(struct branch *b, const char *objectish)
 	return 1;
 }
 
-static int parse_from(struct branch *b)
+static int parse_from(struct __branch *b)
 {
 	const char *from;
 
@@ -2619,7 +2752,7 @@ static int parse_from(struct branch *b)
 	return parse_objectish(b, from);
 }
 
-static int parse_objectish_with_prefix(struct branch *b, const char *prefix)
+static int parse_objectish_with_prefix(struct __branch *b, const char *prefix)
 {
 	const char *base;
 
@@ -2633,7 +2766,7 @@ static struct hash_list *parse_merge(unsigned int *count)
 {
 	struct hash_list *list = NULL, **tail = &list, *n;
 	const char *from;
-	struct branch *s;
+	struct __branch *s;
 
 	*count = 0;
 	while (skip_prefix(command_buf.buf, "merge ", &from)) {
@@ -2643,7 +2776,7 @@ static struct hash_list *parse_merge(unsigned int *count)
 			oidcpy(&n->oid, &s->oid);
 		else if (*from == ':') {
 			uintmax_t idnum = parse_mark_ref_eol(from);
-			struct object_entry *oe = find_mark(marks, idnum);
+			struct object_entry *oe = find_mark(__marks, idnum);
 			if (oe->type != OBJ_COMMIT)
 				die("Mark :%" PRIuMAX " not a commit", idnum);
 			oidcpy(&n->oid, &oe->idx.oid);
@@ -2671,8 +2804,12 @@ static struct hash_list *parse_merge(unsigned int *count)
 
 static void parse_new_commit(const char *arg)
 {
+#ifdef __VSF__
+# define msg (git_ctx->builtin_fast_import.parse_new_commit.__msg)
+#else
 	static struct strbuf msg = STRBUF_INIT;
-	struct branch *b;
+#endif
+	struct __branch *b;
 	char *author = NULL;
 	char *committer = NULL;
 	char *encoding = NULL;
@@ -2778,16 +2915,23 @@ static void parse_new_commit(const char *arg)
 	free(encoding);
 
 	if (!store_object(OBJ_COMMIT, &new_data, NULL, &b->oid, next_mark))
-		b->pack_id = pack_id;
+		b->pack_id = __pack_id;
 	b->last_commit = object_count_by_type[OBJ_COMMIT];
+#ifdef __VSF__
+# undef msg
+#endif
 }
 
 static void parse_new_tag(const char *arg)
 {
+#ifdef __VSF__
+# define msg (git_ctx->builtin_fast_import.parse_new_tag.__msg)
+#else
 	static struct strbuf msg = STRBUF_INIT;
+#endif
 	const char *from;
 	char *tagger;
-	struct branch *s;
+	struct __branch *s;
 	struct tag *t;
 	uintmax_t from_mark = 0;
 	struct object_id oid;
@@ -2817,7 +2961,7 @@ static void parse_new_tag(const char *arg)
 	} else if (*from == ':') {
 		struct object_entry *oe;
 		from_mark = parse_mark_ref_eol(from);
-		oe = find_mark(marks, from_mark);
+		oe = find_mark(__marks, from_mark);
 		type = oe->type;
 		oidcpy(&oid, &oe->idx.oid);
 	} else if (!get_oid(from, &oid)) {
@@ -2863,12 +3007,15 @@ static void parse_new_tag(const char *arg)
 	if (store_object(OBJ_TAG, &new_data, NULL, &t->oid, next_mark))
 		t->pack_id = MAX_PACK_ID;
 	else
-		t->pack_id = pack_id;
+		t->pack_id = __pack_id;
+#ifdef __VSF__
+# undef msg
+#endif
 }
 
 static void parse_reset_branch(const char *arg)
 {
-	struct branch *b;
+	struct __branch *b;
 	const char *tag_name;
 
 	b = lookup_branch(arg);
@@ -2958,7 +3105,7 @@ static void cat_blob(struct object_entry *oe, struct object_id *oid)
 	strbuf_release(&line);
 	cat_blob_write(buf, size);
 	cat_blob_write("\n", 1);
-	if (oe && oe->pack_id == pack_id) {
+	if (oe && oe->pack_id == __pack_id) {
 		last_blob.offset = oe->idx.offset;
 		strbuf_attach(&last_blob.data, buf, size, size);
 		last_blob.depth = oe->depth;
@@ -2975,7 +3122,7 @@ static void parse_get_mark(const char *p)
 	if (*p != ':')
 		die("Not a mark: %s", p);
 
-	oe = find_mark(marks, parse_mark_ref_eol(p));
+	oe = find_mark(__marks, parse_mark_ref_eol(p));
 	if (!oe)
 		die("Unknown mark: %s", command_buf.buf);
 
@@ -2990,7 +3137,7 @@ static void parse_cat_blob(const char *p)
 
 	/* cat-blob SP <object> LF */
 	if (*p == ':') {
-		oe = find_mark(marks, parse_mark_ref_eol(p));
+		oe = find_mark(__marks, parse_mark_ref_eol(p));
 		if (!oe)
 			die("Unknown mark: %s", command_buf.buf);
 		oidcpy(&oid, &oe->idx.oid);
@@ -3101,7 +3248,7 @@ static struct object_entry *parse_treeish_dataref(const char **p)
 	struct object_entry *e;
 
 	if (**p == ':') {	/* <mark> */
-		e = find_mark(marks, parse_mark_ref_space(p));
+		e = find_mark(__marks, parse_mark_ref_space(p));
 		if (!e)
 			die("Unknown mark: %s", command_buf.buf);
 		oidcpy(&oid, &e->idx.oid);
@@ -3120,7 +3267,11 @@ static struct object_entry *parse_treeish_dataref(const char **p)
 
 static void print_ls(int mode, const unsigned char *hash, const char *path)
 {
+#ifdef __VSF__
+# define line (git_ctx->builtin_fast_import.print_ls.__line)
+#else
 	static struct strbuf line = STRBUF_INIT;
+#endif
 
 	/* See show_tree(). */
 	const char *type =
@@ -3143,9 +3294,12 @@ static void print_ls(int mode, const unsigned char *hash, const char *path)
 		strbuf_addch(&line, '\n');
 	}
 	cat_blob_write(line.buf, line.len);
+#ifdef __VSF__
+# undef line
+#endif
 }
 
-static void parse_ls(const char *p, struct branch *b)
+static void parse_ls(const char *p, struct __branch *b)
 {
 	struct tree_entry *root = NULL;
 	struct tree_entry leaf = {NULL};
@@ -3164,7 +3318,11 @@ static void parse_ls(const char *p, struct branch *b)
 		load_tree(root);
 	}
 	if (*p == '"') {
+#ifdef __VSF__
+# define uq (git_ctx->builtin_fast_import.parse_ls.__uq)
+#else
 		static struct strbuf uq = STRBUF_INIT;
+#endif
 		const char *endp;
 		strbuf_reset(&uq);
 		if (unquote_c_style(&uq, p, &endp))
@@ -3172,6 +3330,9 @@ static void parse_ls(const char *p, struct branch *b)
 		if (*endp)
 			die("Garbage after path in: %s", command_buf.buf);
 		p = uq.buf;
+#ifdef __VSF__
+# undef uq
+#endif
 	}
 	tree_content_get(root, p, &leaf, 1);
 	/*
@@ -3216,7 +3377,7 @@ static void parse_progress(void)
 static void parse_alias(void)
 {
 	struct object_entry *e;
-	struct branch b;
+	struct __branch b;
 
 	skip_optional_lf();
 	read_next_command();
@@ -3232,7 +3393,7 @@ static void parse_alias(void)
 		die(_("Expected 'to' command, got %s"), command_buf.buf);
 	e = find_object(&b.oid);
 	assert(e);
-	insert_mark(&marks, next_mark, e);
+	insert_mark(&__marks, next_mark, e);
 }
 
 static char* make_fast_import_path(const char *path)
@@ -3524,7 +3685,7 @@ int cmd_fast_import(int argc, const char **argv, const char *prefix)
 	CALLOC_ARRAY(atom_table, atom_table_sz);
 	CALLOC_ARRAY(branch_table, branch_table_sz);
 	CALLOC_ARRAY(avail_tree_table, avail_tree_table_sz);
-	marks = mem_pool_calloc(&fi_mem_pool, 1, sizeof(struct mark_set));
+	__marks = mem_pool_calloc(&fi_mem_pool, 1, sizeof(struct mark_set));
 
 	hashmap_init(&object_table, object_entry_hashcmp, NULL, 0);
 
@@ -3623,7 +3784,7 @@ int cmd_fast_import(int argc, const char **argv, const char *prefix)
 		fprintf(stderr, "      commits:   %10" PRIuMAX " (%10" PRIuMAX " duplicates %10" PRIuMAX " deltas of %10" PRIuMAX" attempts)\n", object_count_by_type[OBJ_COMMIT], duplicate_count_by_type[OBJ_COMMIT], delta_count_by_type[OBJ_COMMIT], delta_count_attempts_by_type[OBJ_COMMIT]);
 		fprintf(stderr, "      tags   :   %10" PRIuMAX " (%10" PRIuMAX " duplicates %10" PRIuMAX " deltas of %10" PRIuMAX" attempts)\n", object_count_by_type[OBJ_TAG], duplicate_count_by_type[OBJ_TAG], delta_count_by_type[OBJ_TAG], delta_count_attempts_by_type[OBJ_TAG]);
 		fprintf(stderr, "Total branches:  %10lu (%10lu loads     )\n", branch_count, branch_load_count);
-		fprintf(stderr, "      marks:     %10" PRIuMAX " (%10" PRIuMAX " unique    )\n", (((uintmax_t)1) << marks->shift) * 1024, marks_set_count);
+		fprintf(stderr, "      marks:     %10" PRIuMAX " (%10" PRIuMAX " unique    )\n", (((uintmax_t)1) << __marks->shift) * 1024, marks_set_count);
 		fprintf(stderr, "      atoms:     %10u\n", atom_cnt);
 		fprintf(stderr, "Memory total:    %10" PRIuMAX " KiB\n", (tree_entry_allocd + fi_mem_pool.pool_alloc + alloc_count*sizeof(struct object_entry))/1024);
 		fprintf(stderr, "       pools:    %10lu KiB\n", (unsigned long)((tree_entry_allocd + fi_mem_pool.pool_alloc) /1024));
diff --git a/builtin/fetch-pack.c b/builtin/fetch-pack.c
index c2d96f4c89..11f08c7408 100644
--- a/builtin/fetch-pack.c
+++ b/builtin/fetch-pack.c
@@ -2,7 +2,7 @@
 #include "pkt-line.h"
 #include "fetch-pack.h"
 #include "remote.h"
-#include "connect.h"
+#include "../connect.h"
 #include "oid-array.h"
 #include "protocol.h"
 
diff --git a/builtin/send-pack.c b/builtin/send-pack.c
index 69c432ef1a..df7da21017 100644
--- a/builtin/send-pack.c
+++ b/builtin/send-pack.c
@@ -6,7 +6,7 @@
 #include "sideband.h"
 #include "run-command.h"
 #include "remote.h"
-#include "connect.h"
+#include "../connect.h"
 #include "send-pack.h"
 #include "quote.h"
 #include "transport.h"
diff --git a/common-main.c b/common-main.c
index 29fb7452f8..31e7df43e4 100644
--- a/common-main.c
+++ b/common-main.c
@@ -25,6 +25,12 @@ static void restore_sigpipe_to_default(void)
 
 int main(int argc, const char **argv)
 {
+#ifdef __VSF__
+    extern int vsf_linux_git_init(void);
+    if (vsf_linux_git_init() != 0) {
+	    return -1;
+	}
+#endif
 	int result;
 	struct strbuf tmp = STRBUF_INIT;
 
@@ -53,7 +59,11 @@ int main(int argc, const char **argv)
 	if (!strbuf_getcwd(&tmp))
 		tmp_original_cwd = strbuf_detach(&tmp, NULL);
 
-	result = cmd_main(argc, argv);
+	if (!strcmp(argv[0], "git")) {
+		result = cmd_main(argc, argv);
+	} else if (!strcmp(argv[0], "git-remote-https") || !strcmp(argv[0], "git-remote-http")) {
+		result = remote_curl_cmd_main(argc, argv);
+	}
 
 	/*
 	 * We define exit() to call trace2_cmd_exit_fl() in
diff --git a/compat/obstack.c b/compat/obstack.c
index 27cd5c1ea1..73321bf080 100644
--- a/compat/obstack.c
+++ b/compat/obstack.c
@@ -45,6 +45,10 @@
 
 #include <stddef.h>
 
+#ifdef __VSF__
+# include "git_port_vsf.h"
+#endif
+
 #ifndef ELIDE_CODE
 
 
@@ -91,8 +95,12 @@ enum
    abort gracefully or use longjump - but shouldn't return.  This
    variable by default points to the internal function
    `print_and_abort'.  */
+#ifdef __VSF__
+# define obstack_alloc_failed_handler (git_ctx->obstack.__obstack_alloc_failed_handler)
+#else
 static void print_and_abort (void);
 void (*obstack_alloc_failed_handler) (void) = print_and_abort;
+#endif
 
 # ifdef _LIBC
 #  if SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_3_4)
@@ -394,8 +402,13 @@ _obstack_memory_used (struct obstack *h)
 #  endif
 # endif
 
+#ifdef __VSF__
+void
+print_and_abort (void)
+#else
 static void
 print_and_abort (void)
+#endif
 {
   /* Don't change any of these strings.  Yes, it would be possible to add
      the newline to the string and use fputs or so.  But this must not
diff --git a/compat/regex/regcomp.c b/compat/regex/regcomp.c
index d1bc09e49b..670b4294d1 100644
--- a/compat/regex/regcomp.c
+++ b/compat/regex/regcomp.c
@@ -229,6 +229,17 @@ btowc (int c)
 }
 #endif
 
+/* Set by `re_set_syntax' to the current regexp syntax to recognize.  Can
+   also be assigned to arbitrarily: each pattern buffer stores its own
+   syntax, so it can be changed between regex compilations.  */
+/* This has no initializer because initialized variables in Emacs
+   become read-only after dumping.  */
+#ifdef __VSF__
+# define re_syntax_options (git_ctx->regex.__re_syntax_options)
+#else
+reg_syntax_t re_syntax_options;
+#endif
+
 /* re_compile_pattern is the GNU regular expression compiler: it
    compiles PATTERN (of length LENGTH) and puts the result in BUFP.
    Returns 0 if the pattern was valid, otherwise an error string.
@@ -261,13 +272,6 @@ re_compile_pattern (const char *pattern,
 weak_alias (__re_compile_pattern, re_compile_pattern)
 #endif
 
-/* Set by `re_set_syntax' to the current regexp syntax to recognize.  Can
-   also be assigned to arbitrarily: each pattern buffer stores its own
-   syntax, so it can be changed between regex compilations.  */
-/* This has no initializer because initialized variables in Emacs
-   become read-only after dumping.  */
-reg_syntax_t re_syntax_options;
-
 
 /* Specify the precise syntax of regexps for compilation.  This provides
    for compatibility for various utilities which historically have
@@ -597,7 +601,11 @@ static const bitset_t utf8_sb_map = {
   [0 ... 0x80 / BITSET_WORD_BITS - 1] = BITSET_WORD_MAX
 };
 #else /* ! (__GNUC__ >= 3) */
+#ifdef __VSF__
+# define utf8_sb_map (git_ctx->regex.__utf8_sb_map)
+#else
 static bitset_t utf8_sb_map;
+#endif
 #endif /* __GNUC__ >= 3 */
 #endif /* RE_ENABLE_I18N */
 
@@ -677,7 +685,11 @@ weak_alias (__regfree, regfree)
 #if defined _REGEX_RE_COMP || defined _LIBC
 
 /* BSD has one and only one pattern buffer.  */
+#ifdef __VSF__
+# define re_comp_buf (git_ctx->regex.__re_comp_buf)
+#else
 static struct re_pattern_buffer re_comp_buf;
+#endif
 
 char *
 # ifdef _LIBC
@@ -919,7 +931,11 @@ init_dfa (re_dfa_t *dfa, size_t pat_len)
       if (dfa->is_utf8)
         {
 #if !defined(__GNUC__) || __GNUC__ < 3
+#ifdef __VSF__
+# define utf8_sb_map_inited (git_ctx->regex.init_dfa.__utf8_sb_map_inited)
+#else
 	  static short utf8_sb_map_inited = 0;
+#endif
 
 	  if (! utf8_sb_map_inited)
 	    {
diff --git a/compat/regex/regex.c b/compat/regex/regex.c
index e6f4a5d177..e7b6ad9a92 100644
--- a/compat/regex/regex.c
+++ b/compat/regex/regex.c
@@ -75,6 +75,11 @@
 #define true (1)
 #define false (0)
 #endif
+
+#ifdef __VSF__
+# include "git_port_vsf.h"
+#endif
+
 #include "regcomp.c"
 #include "regexec.c"
 
diff --git a/compat/regex/regex_internal.h b/compat/regex/regex_internal.h
index 0bad8b841e..ff11859da3 100644
--- a/compat/regex/regex_internal.h
+++ b/compat/regex/regex_internal.h
@@ -20,6 +20,10 @@
 #ifndef _REGEX_INTERNAL_H
 #define _REGEX_INTERNAL_H 1
 
+#ifdef __VSF__
+#   include "git_config.h"
+#endif
+
 #include <assert.h>
 #include <ctype.h>
 #include <stdio.h>
diff --git a/compat/terminal.c b/compat/terminal.c
index 5b903e7c7e..8c33df57d2 100644
--- a/compat/terminal.c
+++ b/compat/terminal.c
@@ -6,6 +6,10 @@
 #include "string-list.h"
 #include "hashmap.h"
 
+#ifdef __VSF__
+# include "git_port_vsf.h"
+#endif
+
 #if defined(HAVE_DEV_TTY) || defined(GIT_WINDOWS_NATIVE)
 
 static void restore_term_on_signal(int sig)
@@ -20,8 +24,13 @@ static void restore_term_on_signal(int sig)
 #define INPUT_PATH "/dev/tty"
 #define OUTPUT_PATH "/dev/tty"
 
+#ifdef __VSF__
+# define term_fd (git_ctx->terminal.__term_fd)
+# define old_term (git_ctx->terminal.__old_term)
+#else
 static int term_fd = -1;
 static struct termios old_term;
+#endif
 
 void restore_term(void)
 {
@@ -77,11 +86,21 @@ static int enable_non_canonical(void)
 #define OUTPUT_PATH "CONOUT$"
 #define FORCE_TEXT "t"
 
+#ifdef __VSF__
+# error "not supported"
+# define use_stty (git_ctx->terminal.__use_stty)
+# define stty_restore (git_ctx->terminal.__stty_restore)
+# define hconin (git_ctx->terminal.__hconin)
+# define hconout (git_ctx->terminal.__hconout)
+# define cmode_in (git_ctx->terminal.__cmode_in)
+# define cmode_out (git_ctx->terminal.__cmode_out)
+#else
 static int use_stty = 1;
 static struct string_list stty_restore = STRING_LIST_INIT_DUP;
 static HANDLE hconin = INVALID_HANDLE_VALUE;
 static HANDLE hconout = INVALID_HANDLE_VALUE;
 static DWORD cmode_in, cmode_out;
+#endif
 
 void restore_term(void)
 {
@@ -236,7 +255,11 @@ static int mingw_getchar(void)
 
 char *git_terminal_prompt(const char *prompt, int echo)
 {
-	static struct strbuf buf = STRBUF_INIT;
+#ifdef __VSF__
+# define __buf (git_ctx->terminal.git_terminal_prompt.__buf)
+#else
+	static struct strbuf __buf = STRBUF_INIT;
+#endif
 	int r;
 	FILE *input_fh, *output_fh;
 
@@ -259,7 +282,7 @@ char *git_terminal_prompt(const char *prompt, int echo)
 	fputs(prompt, output_fh);
 	fflush(output_fh);
 
-	r = strbuf_getline_lf(&buf, input_fh);
+	r = strbuf_getline_lf(&__buf, input_fh);
 	if (!echo) {
 		putc('\n', output_fh);
 		fflush(output_fh);
@@ -271,7 +294,10 @@ char *git_terminal_prompt(const char *prompt, int echo)
 
 	if (r == EOF)
 		return NULL;
-	return buf.buf;
+	return __buf.buf;
+#ifdef __VSF__
+# undef __buf
+#endif
 }
 
 /*
@@ -297,8 +323,13 @@ static int sequence_entry_cmp(const void *hashmap_cmp_fn_data,
 
 static int is_known_escape_sequence(const char *sequence)
 {
+#ifdef __VSF__
+# define sequences (git_ctx->terminal.is_known_escape_sequence.__sequences)
+# define initialized (git_ctx->terminal.is_known_escape_sequence.__initialized)
+#else
 	static struct hashmap sequences;
 	static int initialized;
+#endif
 
 	if (!initialized) {
 		struct child_process cp = CHILD_PROCESS_INIT;
@@ -337,11 +368,19 @@ static int is_known_escape_sequence(const char *sequence)
 	}
 
 	return !!hashmap_get_from_hash(&sequences, strhash(sequence), sequence);
+#ifdef __VSF__
+# undef sequences
+# undef initialized
+#endif
 }
 
 int read_key_without_echo(struct strbuf *buf)
 {
+#ifdef __VSF__
+# define warning_displayed (git_ctx->terminal.read_key_without_echo.__warning_displayed)
+#else
 	static int warning_displayed;
+#endif
 	int ch;
 
 	if (warning_displayed || enable_non_canonical() < 0) {
@@ -392,6 +431,9 @@ int read_key_without_echo(struct strbuf *buf)
 
 	restore_term();
 	return 0;
+#ifdef __VSF__
+# undef warning_displayed
+#endif
 }
 
 #else
@@ -413,7 +455,11 @@ char *git_terminal_prompt(const char *prompt, int echo)
 
 int read_key_without_echo(struct strbuf *buf)
 {
+#ifdef __VSF__
+# define warning_displayed (git_ctx->terminal.read_key_without_echo.__warning_displayed)
+#else
 	static int warning_displayed;
+#endif
 	const char *res;
 
 	if (!warning_displayed) {
@@ -428,6 +474,9 @@ int read_key_without_echo(struct strbuf *buf)
 		return EOF;
 	strbuf_addstr(buf, res);
 	return 0;
+#ifdef __VSF__
+# undef warning_displayed
+#endif
 }
 
 #endif
diff --git a/ewah/ewah_bitmap.c b/ewah/ewah_bitmap.c
index 2a8c7c5c33..f5da48096c 100644
--- a/ewah/ewah_bitmap.c
+++ b/ewah/ewah_bitmap.c
@@ -21,6 +21,10 @@
 #include "ewok_rlw.h"
 #include "cache.h"
 
+#ifdef __VSF__
+# include "git_port_vsf.h"
+#endif
+
 static inline size_t min_size(size_t a, size_t b)
 {
 	return a < b ? a : b;
@@ -437,9 +441,14 @@ void ewah_xor(
 	out->bit_size = max_size(ewah_i->bit_size, ewah_j->bit_size);
 }
 
+#ifdef __VSF__
+# define bitmap_pool (git_ctx->ewah_bitmap.__bitmap_pool)
+# define bitmap_pool_size (git_ctx->ewah_bitmap.__bitmap_pool_size)
+#else
 #define BITMAP_POOL_MAX 16
 static struct ewah_bitmap *bitmap_pool[BITMAP_POOL_MAX];
 static size_t bitmap_pool_size;
+#endif
 
 struct ewah_bitmap *ewah_pool_new(void)
 {
diff --git a/git-compat-util.h b/git-compat-util.h
index 1229c8296b..b5dafad9a7 100644
--- a/git-compat-util.h
+++ b/git-compat-util.h
@@ -1,6 +1,10 @@
 #ifndef GIT_COMPAT_UTIL_H
 #define GIT_COMPAT_UTIL_H
 
+#ifdef __VSF__
+#	include "git_config.h"
+#endif
+
 #if __STDC_VERSION__ - 0 < 199901L
 /*
  * Git is in a testing period for mandatory C99 support in the compiler.  If
@@ -1364,7 +1368,10 @@ int cmd_main(int, const char **);
  * optionally emit a message before calling the real exit().
  */
 int trace2_cmd_exit_fl(const char *file, int line, int code);
+#ifndef __VSF__
+// in VSF raw exit maybe the real exit in host_os, vsf will be exited if called
 #define exit(code) exit(trace2_cmd_exit_fl(__FILE__, __LINE__, (code)))
+#endif
 
 /*
  * You can mark a stack variable with UNLEAK(var) to avoid it being
diff --git a/negotiator/default.c b/negotiator/default.c
index 434189ae5d..85ade8c2c1 100644
--- a/negotiator/default.c
+++ b/negotiator/default.c
@@ -6,13 +6,21 @@
 #include "../refs.h"
 #include "../tag.h"
 
+#ifdef __VSF__
+# include "git_port_vsf.h"
+#endif
+
 /* Remember to update object flag allocation in object.h */
 #define COMMON		(1U << 2)
 #define COMMON_REF	(1U << 3)
 #define SEEN		(1U << 4)
 #define POPPED		(1U << 5)
 
+#ifdef __VSF__
+# define marked (git_ctx->negotiator_default.__marked)
+#else
 static int marked;
+#endif
 
 struct negotiation_state {
 	struct prio_queue rev_list;
diff --git a/negotiator/skipping.c b/negotiator/skipping.c
index 1236e79224..1a1e9a2bba 100644
--- a/negotiator/skipping.c
+++ b/negotiator/skipping.c
@@ -6,6 +6,10 @@
 #include "../refs.h"
 #include "../tag.h"
 
+#ifdef __VSF__
+# include "git_port_vsf.h"
+#endif
+
 /* Remember to update object flag allocation in object.h */
 /*
  * Both us and the server know that both parties have this object.
@@ -26,7 +30,11 @@
  */
 #define POPPED		(1U << 5)
 
+#ifdef __VSF__
+# define marked (git_ctx->negotiator_skipping.__marked)
+#else
 static int marked;
+#endif
 
 /*
  * An entry in the priority queue.
diff --git a/refs.c b/refs.c
index addb26293b..33632bff8a 100644
--- a/refs.c
+++ b/refs.c
@@ -20,10 +20,18 @@
 #include "repository.h"
 #include "sigchain.h"
 
+#ifdef __VSF__
+# include "git_port_vsf.h"
+#endif
+
 /*
  * List of all available backends
  */
+#ifdef __VSF__
+# define refs_backends (git_ctx->refs.__refs_backends)
+#else
 static struct ref_storage_be *refs_backends = &refs_be_files;
+#endif
 
 static struct ref_storage_be *find_ref_storage_backend(const char *name)
 {
@@ -44,7 +52,7 @@ static struct ref_storage_be *find_ref_storage_backend(const char *name)
  *    ":", "?", "[", "\", "^", "~", SP, or TAB
  * 5: *, reject unless REFNAME_REFSPEC_PATTERN is set
  */
-static unsigned char refname_disposition[256] = {
+static const unsigned char refname_disposition[256] = {
 	1, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
 	4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
 	4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 2, 1,
@@ -600,12 +608,19 @@ char *repo_default_branch_name(struct repository *r, int quiet)
 
 const char *git_default_branch_name(int quiet)
 {
+#ifdef __VSF__
+# define ret (git_ctx->refs.git_default_branch_name.__ret)
+#else
 	static char *ret;
+#endif
 
 	if (!ret)
 		ret = repo_default_branch_name(the_repository, quiet);
 
 	return ret;
+#ifdef __VSF__
+# undef ret
+#endif
 }
 
 /*
@@ -779,10 +794,15 @@ enum ref_type ref_type(const char *refname)
 
 long get_files_ref_lock_timeout_ms(void)
 {
+#ifdef __VSF__
+# define configured (git_ctx->refs.get_files_ref_lock_timeout_ms.__configured)
+# define timeout_ms (git_ctx->refs.get_files_ref_lock_timeout_ms.__timeout_ms)
+#else
 	static int configured = 0;
 
 	/* The default timeout is 100 ms: */
 	static int timeout_ms = 100;
+#endif
 
 	if (!configured) {
 		git_config_get_int("core.filesreflocktimeout", &timeout_ms);
@@ -790,6 +810,10 @@ long get_files_ref_lock_timeout_ms(void)
 	}
 
 	return timeout_ms;
+#ifdef __VSF__
+# undef configured
+# undef timeout_ms
+#endif
 }
 
 int refs_delete_ref(struct ref_store *refs, const char *msg,
@@ -1199,8 +1223,13 @@ char *refs_shorten_unambiguous_ref(struct ref_store *refs,
 				   const char *refname, int strict)
 {
 	int i;
+#ifdef __VSF__
+# define scanf_fmts (git_ctx->refs.refs_shorten_unambiguous_ref.__scanf_fmts)
+# define nr_rules (git_ctx->refs.refs_shorten_unambiguous_ref.__nr_rules)
+#else
 	static char **scanf_fmts;
 	static int nr_rules;
+#endif
 	char *short_name;
 	struct strbuf resolved_buf = STRBUF_INIT;
 
@@ -1291,6 +1320,10 @@ char *refs_shorten_unambiguous_ref(struct ref_store *refs,
 	strbuf_release(&resolved_buf);
 	free(short_name);
 	return xstrdup(refname);
+#ifdef __VSF__
+# undef scanf_fmts
+# undef nr_rules
+#endif
 }
 
 char *shorten_unambiguous_ref(const char *refname, int strict)
@@ -1299,7 +1332,11 @@ char *shorten_unambiguous_ref(const char *refname, int strict)
 					    refname, strict);
 }
 
+#ifdef __VSF__
+# define hide_refs (git_ctx->refs.__hide_refs)
+#else
 static struct string_list *hide_refs;
+#endif
 
 int parse_hide_refs_config(const char *var, const char *value, const char *section)
 {
@@ -1412,7 +1449,11 @@ struct ref_iterator *refs_ref_iterator_begin(
 	struct ref_iterator *iter;
 
 	if (!(flags & DO_FOR_EACH_INCLUDE_BROKEN)) {
+#ifdef __VSF__
+# define ref_paranoia (git_ctx->refs.refs_ref_iterator_begin.__ref_paranoia)
+#else
 		static int ref_paranoia = -1;
+#endif
 
 		if (ref_paranoia < 0)
 			ref_paranoia = git_env_bool("GIT_REF_PARANOIA", 1);
@@ -1420,6 +1461,9 @@ struct ref_iterator *refs_ref_iterator_begin(
 			flags |= DO_FOR_EACH_INCLUDE_BROKEN;
 			flags |= DO_FOR_EACH_OMIT_DANGLING_SYMREFS;
 		}
+#ifdef __VSF__
+# undef ref_paranoia
+#endif
 	}
 
 	iter = refs->be->iterator_begin(refs, prefix, flags);
@@ -1684,7 +1728,11 @@ const char *refs_resolve_ref_unsafe(struct ref_store *refs,
 				    struct object_id *oid,
 				    int *flags, int *failure_errno)
 {
+#ifdef __VSF__
+# define sb_refname (git_ctx->refs.refs_resolve_ref_unsafe.__sb_refname)
+#else
 	static struct strbuf sb_refname = STRBUF_INIT;
+#endif
 	struct object_id unused_oid;
 	int unused_flags;
 	int symref_count;
@@ -1771,6 +1819,9 @@ const char *refs_resolve_ref_unsafe(struct ref_store *refs,
 
 	*failure_errno = ELOOP;
 	return NULL;
+#ifdef __VSF__
+# undef sb_refname
+#endif
 }
 
 /* backend functions */
@@ -1844,11 +1895,16 @@ static struct ref_store_hash_entry *alloc_ref_store_hash_entry(
 	return entry;
 }
 
+#ifdef __VSF__
+# define submodule_ref_stores (git_ctx->refs.__submodule_ref_stores)
+# define worktree_ref_stores (git_ctx->refs.__worktree_ref_stores)
+#else
 /* A hashmap of ref_stores, stored by submodule name: */
 static struct hashmap submodule_ref_stores;
 
 /* A hashmap of ref_stores, stored by worktree id: */
 static struct hashmap worktree_ref_stores;
+#endif
 
 /*
  * Look up a ref store by name. If that ref_store hasn't been
diff --git a/refs/debug.c b/refs/debug.c
index 2b0771ca53..93e9d2282a 100644
--- a/refs/debug.c
+++ b/refs/debug.c
@@ -2,14 +2,22 @@
 #include "refs-internal.h"
 #include "trace.h"
 
+#ifdef __VSF__
+# include "git_port_vsf.h"
+#endif
+
+#ifdef __VSF__
+# define trace_refs (git_ctx->refs_debug.__trace_refs)
+#else
 static struct trace_key trace_refs = TRACE_KEY_INIT(REFS);
+#endif
 
 struct debug_ref_store {
 	struct ref_store base;
 	struct ref_store *refs;
 };
 
-extern struct ref_storage_be refs_be_debug;
+extern const struct ref_storage_be refs_be_debug;
 
 struct ref_store *maybe_debug_wrap_ref_store(const char *gitdir, struct ref_store *store)
 {
@@ -219,7 +227,7 @@ static int debug_ref_iterator_abort(struct ref_iterator *ref_iterator)
 	return res;
 }
 
-static struct ref_iterator_vtable debug_ref_iterator_vtable = {
+static const struct ref_iterator_vtable debug_ref_iterator_vtable = {
 	debug_ref_iterator_advance, debug_ref_iterator_peel,
 	debug_ref_iterator_abort
 };
@@ -417,7 +425,7 @@ static int debug_reflog_expire(struct ref_store *ref_store, const char *refname,
 	return res;
 }
 
-struct ref_storage_be refs_be_debug = {
+const struct ref_storage_be refs_be_debug = {
 	NULL,
 	"debug",
 	NULL,
diff --git a/refs/files-backend.c b/refs/files-backend.c
index 43a3b882d7..d1753be2cd 100644
--- a/refs/files-backend.c
+++ b/refs/files-backend.c
@@ -800,7 +800,7 @@ static int files_ref_iterator_abort(struct ref_iterator *ref_iterator)
 	return ok;
 }
 
-static struct ref_iterator_vtable files_ref_iterator_vtable = {
+static const struct ref_iterator_vtable files_ref_iterator_vtable = {
 	files_ref_iterator_advance,
 	files_ref_iterator_peel,
 	files_ref_iterator_abort
@@ -1754,7 +1754,7 @@ static int write_ref_to_lockfile(struct ref_lock *lock,
 				 const struct object_id *oid,
 				 int skip_oid_verification, struct strbuf *err)
 {
-	static char term = '\n';
+	static const char term = '\n';
 	struct object *o;
 	int fd;
 
@@ -2207,7 +2207,7 @@ static int files_reflog_iterator_abort(struct ref_iterator *ref_iterator)
 	return ok;
 }
 
-static struct ref_iterator_vtable files_reflog_iterator_vtable = {
+static const struct ref_iterator_vtable files_reflog_iterator_vtable = {
 	files_reflog_iterator_advance,
 	files_reflog_iterator_peel,
 	files_reflog_iterator_abort
@@ -3269,7 +3269,7 @@ static int files_init_db(struct ref_store *ref_store, struct strbuf *err)
 	return 0;
 }
 
-struct ref_storage_be refs_be_files = {
+const struct ref_storage_be refs_be_files = {
 	NULL,
 	"files",
 	files_ref_store_create,
diff --git a/refs/iterator.c b/refs/iterator.c
index a89d132d4f..1ba394a694 100644
--- a/refs/iterator.c
+++ b/refs/iterator.c
@@ -8,6 +8,10 @@
 #include "refs/refs-internal.h"
 #include "iterator.h"
 
+#ifdef __VSF__
+# include "git_port_vsf.h"
+#endif
+
 int ref_iterator_advance(struct ref_iterator *ref_iterator)
 {
 	return ref_iterator->vtable->advance(ref_iterator);
@@ -63,7 +67,7 @@ static int empty_ref_iterator_abort(struct ref_iterator *ref_iterator)
 	return ITER_DONE;
 }
 
-static struct ref_iterator_vtable empty_ref_iterator_vtable = {
+static const struct ref_iterator_vtable empty_ref_iterator_vtable = {
 	empty_ref_iterator_advance,
 	empty_ref_iterator_peel,
 	empty_ref_iterator_abort
@@ -200,7 +204,7 @@ static int merge_ref_iterator_abort(struct ref_iterator *ref_iterator)
 	return ok;
 }
 
-static struct ref_iterator_vtable merge_ref_iterator_vtable = {
+static const struct ref_iterator_vtable merge_ref_iterator_vtable = {
 	merge_ref_iterator_advance,
 	merge_ref_iterator_peel,
 	merge_ref_iterator_abort
@@ -377,7 +381,7 @@ static int prefix_ref_iterator_abort(struct ref_iterator *ref_iterator)
 	return ok;
 }
 
-static struct ref_iterator_vtable prefix_ref_iterator_vtable = {
+static const struct ref_iterator_vtable prefix_ref_iterator_vtable = {
 	prefix_ref_iterator_advance,
 	prefix_ref_iterator_peel,
 	prefix_ref_iterator_abort
@@ -405,7 +409,11 @@ struct ref_iterator *prefix_ref_iterator_begin(struct ref_iterator *iter0,
 	return ref_iterator;
 }
 
+#ifdef __VSF__
+# define current_ref_iter (git_ctx->refs_iterator.__current_ref_iter)
+#else
 struct ref_iterator *current_ref_iter = NULL;
+#endif
 
 int do_for_each_repo_ref_iterator(struct repository *r, struct ref_iterator *iter,
 				  each_repo_ref_fn fn, void *cb_data)
diff --git a/refs/packed-backend.c b/refs/packed-backend.c
index d91a2018f6..be94af8294 100644
--- a/refs/packed-backend.c
+++ b/refs/packed-backend.c
@@ -7,6 +7,13 @@
 #include "../lockfile.h"
 #include "../chdir-notify.h"
 
+#ifdef __VSF__
+# include "git_port_vsf.h"
+#endif
+
+#ifdef __VSF__
+# define mmap_strategy (git_ctx->refs_packed_backend.__mmap_strategy)
+#else
 enum mmap_strategy {
 	/*
 	 * Don't use mmap() at all for reading `packed-refs`.
@@ -35,6 +42,7 @@ static enum mmap_strategy mmap_strategy = MMAP_TEMPORARY;
 #else
 static enum mmap_strategy mmap_strategy = MMAP_OK;
 #endif
+#endif
 
 struct packed_ref_store;
 
@@ -910,7 +918,7 @@ static int packed_ref_iterator_abort(struct ref_iterator *ref_iterator)
 	return ok;
 }
 
-static struct ref_iterator_vtable packed_ref_iterator_vtable = {
+static const struct ref_iterator_vtable packed_ref_iterator_vtable = {
 	packed_ref_iterator_advance,
 	packed_ref_iterator_peel,
 	packed_ref_iterator_abort
@@ -991,8 +999,13 @@ int packed_refs_lock(struct ref_store *ref_store, int flags, struct strbuf *err)
 	struct packed_ref_store *refs =
 		packed_downcast(ref_store, REF_STORE_WRITE | REF_STORE_MAIN,
 				"packed_refs_lock");
+#ifdef __VSF__
+# define timeout_configured (git_ctx->refs_packed_backend.packed_refs_lock.__timeout_configured)
+# define timeout_value (git_ctx->refs_packed_backend.packed_refs_lock.__timeout_value)
+#else
 	static int timeout_configured = 0;
 	static int timeout_value = 1000;
+#endif
 
 	if (!timeout_configured) {
 		git_config_get_int("core.packedrefstimeout", &timeout_value);
@@ -1652,7 +1665,7 @@ static int packed_reflog_expire(struct ref_store *ref_store,
 	return 0;
 }
 
-struct ref_storage_be refs_be_packed = {
+const struct ref_storage_be refs_be_packed = {
 	NULL,
 	"packed",
 	packed_ref_store_create,
diff --git a/refs/ref-cache.c b/refs/ref-cache.c
index be4aa5e098..3398f79234 100644
--- a/refs/ref-cache.c
+++ b/refs/ref-cache.c
@@ -455,7 +455,7 @@ static int cache_ref_iterator_abort(struct ref_iterator *ref_iterator)
 	return ITER_DONE;
 }
 
-static struct ref_iterator_vtable cache_ref_iterator_vtable = {
+static const struct ref_iterator_vtable cache_ref_iterator_vtable = {
 	cache_ref_iterator_advance,
 	cache_ref_iterator_peel,
 	cache_ref_iterator_abort
diff --git a/refs/refs-internal.h b/refs/refs-internal.h
index 7ff6fba4f0..4bb6a03cf1 100644
--- a/refs/refs-internal.h
+++ b/refs/refs-internal.h
@@ -492,7 +492,11 @@ struct ref_iterator_vtable {
  * refname lookup in a common case. current_ref_iter is set to NULL
  * when the iteration is over.
  */
+#ifdef __VSF__
+# define current_ref_iter (git_ctx->refs_iterator.__current_ref_iter)
+#else
 extern struct ref_iterator *current_ref_iter;
+#endif
 
 /*
  * The common backend for the for_each_*ref* functions. Call fn for
@@ -677,8 +681,8 @@ struct ref_storage_be {
 	reflog_expire_fn *reflog_expire;
 };
 
-extern struct ref_storage_be refs_be_files;
-extern struct ref_storage_be refs_be_packed;
+extern const struct ref_storage_be refs_be_files;
+extern const struct ref_storage_be refs_be_packed;
 
 /*
  * A representation of the reference store for the main repository or
diff --git a/trace.h b/trace.h
index e25984051a..3a38858046 100644
--- a/trace.h
+++ b/trace.h
@@ -81,7 +81,11 @@
  * the `trace_key` structure.
  */
 struct trace_key {
+#ifdef __VSF__
+    const char * key;
+#else
 	const char * const key;
+#endif
 	int fd;
 	unsigned int initialized : 1;
 	unsigned int  need_close : 1;
diff --git a/trace2.c b/trace2.c
index b2d471526f..11a6610edf 100644
--- a/trace2.c
+++ b/trace2.c
@@ -14,6 +14,17 @@
 #include "trace2/tr2_tgt.h"
 #include "trace2/tr2_tls.h"
 
+#ifdef __VSF__
+# include "git_port_vsf.h"
+#endif
+
+#ifdef __VSF__
+# define trace2_enabled (git_ctx->trace2.__trace2_enabled)
+# define tr2_next_child_id (git_ctx->trace2.__tr2_next_child_id)
+# define tr2_next_exec_id (git_ctx->trace2.__tr2_next_exec_id)
+# define tr2_next_repo_id (git_ctx->trace2.__tr2_next_repo_id)
+# define tr2_tgt_builtins (git_ctx->trace2.__tr2_tgt_builtins)
+#else
 static int trace2_enabled;
 
 static int tr2_next_child_id; /* modify under lock */
@@ -34,6 +45,7 @@ static struct tr2_tgt *tr2_tgt_builtins[] =
 	NULL
 };
 /* clang-format on */
+#endif
 
 /* clang-format off */
 #define for_each_builtin(j, tgt_j)			\
@@ -83,7 +95,11 @@ static void tr2_tgt_disable_builtins(void)
 		tgt_j->pfn_term();
 }
 
+#ifdef __VSF__
+# define tr2main_exit_code (git_ctx->trace2.__tr2main_exit_code)
+#else
 static int tr2main_exit_code;
+#endif
 
 /*
  * Our atexit routine should run after everything has finished.
diff --git a/trace2/tr2_cfg.c b/trace2/tr2_cfg.c
index ec9ac1a6ef..6308e2ab41 100644
--- a/trace2/tr2_cfg.c
+++ b/trace2/tr2_cfg.c
@@ -3,6 +3,18 @@
 #include "trace2/tr2_cfg.h"
 #include "trace2/tr2_sysenv.h"
 
+#ifdef __VSF__
+# include "git_port_vsf.h"
+#endif
+
+#ifdef __VSF__
+# define tr2_cfg_patterns (git_ctx->tr2_cfg.__tr2_cfg_patterns)
+# define tr2_cfg_count_patterns (git_ctx->tr2_cfg.__tr2_cfg_count_patterns)
+# define tr2_cfg_loaded (git_ctx->tr2_cfg.__tr2_cfg_loaded)
+# define tr2_cfg_env_vars (git_ctx->tr2_cfg.__tr2_cfg_env_vars)
+# define tr2_cfg_env_vars_count (git_ctx->tr2_cfg.__tr2_cfg_env_vars_count)
+# define tr2_cfg_env_vars_loaded (git_ctx->tr2_cfg.__tr2_cfg_env_vars_loaded)
+#else
 static struct strbuf **tr2_cfg_patterns;
 static int tr2_cfg_count_patterns;
 static int tr2_cfg_loaded;
@@ -10,6 +22,7 @@ static int tr2_cfg_loaded;
 static struct strbuf **tr2_cfg_env_vars;
 static int tr2_cfg_env_vars_count;
 static int tr2_cfg_env_vars_loaded;
+#endif
 
 /*
  * Parse a string containing a comma-delimited list of config keys
diff --git a/trace2/tr2_cmd_name.c b/trace2/tr2_cmd_name.c
index dd313204f5..a2d0688e34 100644
--- a/trace2/tr2_cmd_name.c
+++ b/trace2/tr2_cmd_name.c
@@ -1,9 +1,17 @@
 #include "cache.h"
 #include "trace2/tr2_cmd_name.h"
 
+#ifdef __VSF__
+# include "git_port_vsf.h"
+#endif
+
 #define TR2_ENVVAR_PARENT_NAME "GIT_TRACE2_PARENT_NAME"
 
+#ifdef __VSF__
+# define tr2cmdname_hierarchy (git_ctx->tr2_cmd_name.__tr2cmdname_hierarchy)
+#else
 static struct strbuf tr2cmdname_hierarchy = STRBUF_INIT;
+#endif
 
 void tr2_cmd_name_append_hierarchy(const char *name)
 {
diff --git a/trace2/tr2_dst.c b/trace2/tr2_dst.c
index 8a21dd2972..44774051ca 100644
--- a/trace2/tr2_dst.c
+++ b/trace2/tr2_dst.c
@@ -4,6 +4,10 @@
 #include "trace2/tr2_sid.h"
 #include "trace2/tr2_sysenv.h"
 
+#ifdef __VSF__
+# include "git_port_vsf.h"
+#endif
+
 /*
  * How many attempts we will make at creating an automatically-named trace file.
  */
@@ -20,11 +24,19 @@
  * how many files we can write to a directory before entering discard mode.
  * This can be overridden via the TR2_SYSENV_MAX_FILES setting.
  */
+#ifdef __VSF__
+# define tr2env_max_files (git_ctx->tr2_dst.__tr2env_max_files)
+#else
 static int tr2env_max_files = 0;
+#endif
 
 static int tr2_dst_want_warning(void)
 {
+#ifdef __VSF__
+# define tr2env_dst_debug (git_ctx->tr2_dst.tr2_dst_want_warning.__tr2env_dst_debug)
+#else
 	static int tr2env_dst_debug = -1;
+#endif
 
 	if (tr2env_dst_debug == -1) {
 		const char *env_value = tr2_sysenv_get(TR2_SYSENV_DST_DEBUG);
diff --git a/trace2/tr2_sid.c b/trace2/tr2_sid.c
index dc6e75ef13..a3d1dc3173 100644
--- a/trace2/tr2_sid.c
+++ b/trace2/tr2_sid.c
@@ -2,10 +2,19 @@
 #include "trace2/tr2_tbuf.h"
 #include "trace2/tr2_sid.h"
 
+#ifdef __VSF__
+# include "git_port_vsf.h"
+#endif
+
 #define TR2_ENVVAR_PARENT_SID "GIT_TRACE2_PARENT_SID"
 
+#ifdef __VSF__
+# define tr2sid_buf (git_ctx->tr2_sid.__tr2sid_buf)
+# define tr2sid_nr_git_parents (git_ctx->tr2_sid.__tr2sid_nr_git_parents)
+#else
 static struct strbuf tr2sid_buf = STRBUF_INIT;
 static int tr2sid_nr_git_parents;
+#endif
 
 /*
  * Compute the final component of the SID representing the current process.
diff --git a/trace2/tr2_sysenv.c b/trace2/tr2_sysenv.c
index a380dcf910..609a0ddadd 100644
--- a/trace2/tr2_sysenv.c
+++ b/trace2/tr2_sysenv.c
@@ -3,6 +3,14 @@
 #include "dir.h"
 #include "tr2_sysenv.h"
 
+#ifdef __VSF__
+# include "git_port_vsf.h"
+#endif
+
+#ifdef __VSF__
+# define tr2_sysenv_settings (git_ctx->tr2_sysenv.__tr2_sysenv_settings)
+#else
+
 /*
  * Each entry represents a trace2 setting.
  * See Documentation/technical/api-trace2.txt
@@ -56,6 +64,7 @@ static struct tr2_sysenv_entry tr2_sysenv_settings[] = {
 				       "trace2.maxfiles" },
 };
 /* clang-format on */
+#endif
 
 static int tr2_sysenv_cb(const char *key, const char *value, void *d)
 {
diff --git a/trace2/tr2_tgt.h b/trace2/tr2_tgt.h
index 65f94e1574..40b15e1141 100644
--- a/trace2/tr2_tgt.h
+++ b/trace2/tr2_tgt.h
@@ -135,8 +135,18 @@ struct tr2_tgt {
 };
 /* clang-format on */
 
+#ifdef __VSF__
+extern const struct tr2_tgt __tr2_tgt_event;
+extern const struct tr2_tgt __tr2_tgt_normal;
+extern const struct tr2_tgt __tr2_tgt_perf;
+
+# define tr2_tgt_event (git_ctx->__tr2_tgt_event.__tr2_tgt_event)
+# define tr2_tgt_normal (git_ctx->__tr2_tgt_normal.__tr2_tgt_normal)
+# define tr2_tgt_perf (git_ctx->__tr2_tgt_perf.__tr2_tgt_perf)
+#else
 extern struct tr2_tgt tr2_tgt_event;
 extern struct tr2_tgt tr2_tgt_normal;
 extern struct tr2_tgt tr2_tgt_perf;
+#endif
 
 #endif /* TR2_TGT_H */
diff --git a/trace2/tr2_tgt_event.c b/trace2/tr2_tgt_event.c
index bd17ecdc32..d0cfafb4c0 100644
--- a/trace2/tr2_tgt_event.c
+++ b/trace2/tr2_tgt_event.c
@@ -10,7 +10,15 @@
 #include "trace2/tr2_tgt.h"
 #include "trace2/tr2_tls.h"
 
+#ifdef __VSF__
+# include "git_port_vsf.h"
+#endif
+
+#ifdef __VSF__
+# define tr2dst_event (git_ctx->__tr2_tgt_event.__tr2dst_event)
+#else
 static struct tr2_dst tr2dst_event = { TR2_SYSENV_EVENT, 0, 0, 0, 0 };
+#endif
 
 /*
  * The version number of the JSON data generated by the EVENT target in this
@@ -22,6 +30,10 @@ static struct tr2_dst tr2dst_event = { TR2_SYSENV_EVENT, 0, 0, 0, 0 };
  */
 #define TR2_EVENT_VERSION "3"
 
+#ifdef __VSF__
+# define tr2env_event_max_nesting_levels (git_ctx->__tr2_tgt_event.__tr2env_event_max_nesting_levels)
+# define tr2env_event_be_brief (git_ctx->__tr2_tgt_event.__tr2env_event_be_brief)
+#else
 /*
  * Region nesting limit for messages written to the event target.
  *
@@ -40,6 +52,7 @@ static int tr2env_event_max_nesting_levels = 2;
  * <line> fields from most events.
  */
 static int tr2env_event_be_brief;
+#endif
 
 static int fn_init(void)
 {
@@ -612,8 +625,13 @@ static void fn_data_json_fl(const char *file, int line,
 	}
 }
 
+#ifdef __VSF__
+const struct tr2_tgt __tr2_tgt_event = {
+	NULL,	//&tr2dst_event,
+#else
 struct tr2_tgt tr2_tgt_event = {
 	&tr2dst_event,
+#endif
 
 	fn_init,
 	fn_term,
diff --git a/trace2/tr2_tgt_normal.c b/trace2/tr2_tgt_normal.c
index 6e429a3fb9..e5dfd199ce 100644
--- a/trace2/tr2_tgt_normal.c
+++ b/trace2/tr2_tgt_normal.c
@@ -9,6 +9,14 @@
 #include "trace2/tr2_tgt.h"
 #include "trace2/tr2_tls.h"
 
+#ifdef __VSF__
+# include "git_port_vsf.h"
+#endif
+
+#ifdef __VSF__
+# define tr2dst_normal (git_ctx->__tr2_tgt_normal.__tr2dst_normal)
+# define tr2env_normal_be_brief (git_ctx->__tr2_tgt_normal.__tr2env_normal_be_brief)
+#else
 static struct tr2_dst tr2dst_normal = { TR2_SYSENV_NORMAL, 0, 0, 0, 0 };
 
 /*
@@ -18,6 +26,7 @@ static struct tr2_dst tr2dst_normal = { TR2_SYSENV_NORMAL, 0, 0, 0, 0 };
  * Unit tests may want to use this to help with testing.
  */
 static int tr2env_normal_be_brief;
+#endif
 
 #define TR2FMT_NORMAL_FL_WIDTH (50)
 
@@ -324,8 +333,13 @@ static void fn_printf_va_fl(const char *file, int line,
 	strbuf_release(&buf_payload);
 }
 
-struct tr2_tgt tr2_tgt_normal = {
+#ifdef __VSF__
+const struct tr2_tgt __tr2_tgt_normal = {
+	NULL,	//&tr2dst_normal,
+#else
+const struct tr2_tgt tr2_tgt_normal = {
 	&tr2dst_normal,
+#endif
 
 	fn_init,
 	fn_term,
diff --git a/trace2/tr2_tgt_perf.c b/trace2/tr2_tgt_perf.c
index 2ff9cf7083..f34460660a 100644
--- a/trace2/tr2_tgt_perf.c
+++ b/trace2/tr2_tgt_perf.c
@@ -11,6 +11,14 @@
 #include "trace2/tr2_tgt.h"
 #include "trace2/tr2_tls.h"
 
+#ifdef __VSF__
+# include "git_port_vsf.h"
+#endif
+
+#ifdef __VSF__
+# define tr2dst_perf (git_ctx->__tr2_tgt_perf.__tr2dst_perf)
+# define tr2env_perf_be_brief (git_ctx->__tr2_tgt_perf.__tr2env_perf_be_brief)
+#else
 static struct tr2_dst tr2dst_perf = { TR2_SYSENV_PERF, 0, 0, 0, 0 };
 
 /*
@@ -20,6 +28,7 @@ static struct tr2_dst tr2dst_perf = { TR2_SYSENV_PERF, 0, 0, 0, 0 };
  * Unit tests may want to use this to help with testing.
  */
 static int tr2env_perf_be_brief;
+#endif
 
 #define TR2FMT_PERF_FL_WIDTH (28)
 #define TR2FMT_PERF_MAX_EVENT_NAME (12)
@@ -548,8 +557,13 @@ static void fn_printf_va_fl(const char *file, int line,
 	strbuf_release(&buf_payload);
 }
 
-struct tr2_tgt tr2_tgt_perf = {
+#ifdef __VSF__
+const struct tr2_tgt __tr2_tgt_perf = {
+	NULL,	//&tr2dst_perf,
+#else
+const struct tr2_tgt tr2_tgt_perf = {
 	&tr2dst_perf,
+#endif
 
 	fn_init,
 	fn_term,
diff --git a/trace2/tr2_tls.c b/trace2/tr2_tls.c
index 7da94aba52..7a0c888972 100644
--- a/trace2/tr2_tls.c
+++ b/trace2/tr2_tls.c
@@ -2,6 +2,10 @@
 #include "thread-utils.h"
 #include "trace2/tr2_tls.h"
 
+#ifdef __VSF__
+# include "git_port_vsf.h"
+#endif
+
 /*
  * Initialize size of the thread stack for nested regions.
  * This is used to store nested region start times.  Note that
@@ -9,6 +13,13 @@
  */
 #define TR2_REGION_NESTING_INITIAL_SIZE (100)
 
+#ifdef __VSF__
+# define tr2tls_thread_main (git_ctx->tr2_tls.__tr2tls_thread_main)
+# define tr2tls_us_start_process (git_ctx->tr2_tls.__tr2tls_us_start_process)
+# define tr2tls_mutex (git_ctx->tr2_tls.__tr2tls_mutex)
+# define tr2tls_key (git_ctx->tr2_tls.__tr2tls_key)
+# define tr2_next_thread_id (git_ctx->tr2_tls.__tr2_next_thread_id)
+#else
 static struct tr2tls_thread_ctx *tr2tls_thread_main;
 static uint64_t tr2tls_us_start_process;
 
@@ -16,6 +27,7 @@ static pthread_mutex_t tr2tls_mutex;
 static pthread_key_t tr2tls_key;
 
 static int tr2_next_thread_id; /* modify under lock */
+#endif
 
 void tr2tls_start_process_clock(void)
 {
